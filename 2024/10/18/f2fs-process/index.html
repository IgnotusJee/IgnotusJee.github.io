<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>F2FS 文件流程浅析 | Blognotus</title><meta name="author" content="柳苏明"><meta name="copyright" content="柳苏明"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文简要梳理了 f2fs 文件系统的组织方式和操作流程。">
<meta property="og:type" content="article">
<meta property="og:title" content="F2FS 文件流程浅析">
<meta property="og:url" content="https://ignotusjee.github.io/2024/10/18/f2fs-process/index.html">
<meta property="og:site_name" content="Blognotus">
<meta property="og:description" content="本文简要梳理了 f2fs 文件系统的组织方式和操作流程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ignotusjee.github.io/img/pic14.jpg">
<meta property="article:published_time" content="2024-10-18T14:26:27.000Z">
<meta property="article:modified_time" content="2024-10-18T14:31:54.629Z">
<meta property="article:author" content="柳苏明">
<meta property="article:tag" content="文件系统">
<meta property="article:tag" content="sys">
<meta property="article:tag" content="Linux kernel">
<meta property="article:tag" content="f2fs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ignotusjee.github.io/img/pic14.jpg"><link rel="shortcut icon" href="/img/logo/1.jpg"><link rel="canonical" href="https://ignotusjee.github.io/2024/10/18/f2fs-process/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-STPMLF8JXN"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-STPMLF8JXN')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-STPMLF8JXN', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'F2FS 文件流程浅析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-18 22:31:54'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/flat-top.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/img/pic6.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/pic14.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blognotus</span></a><a class="nav-page-title" href="/"><span class="site-name">F2FS 文件流程浅析</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">F2FS 文件流程浅析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-18T14:26:27.000Z" title="发表于 2024-10-18 22:26:27">2024-10-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-18T14:31:54.629Z" title="更新于 2024-10-18 22:31:54">2024-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/sys/">sys</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文简要梳理了 f2fs 文件系统的组织方式和操作流程。</p>
<span id="more"></span>
<h1>f2fs 文件组织形式和典型流程</h1>
<h2 id="重要结构">重要结构</h2>
<h3 id="文件结构">文件结构</h3>
<p>文件数据的组织方式一般时被设计为inode-data模式，即 每一个文件都具有一个inode，这个inode记录data的组织关系，这个关系称为<strong>文件结构</strong>。例如用户需要访问A文件的第1000个字节，系统就会先根据A文件的路径找到的A的inode，然后从inode找到第1000个字节所在的物理地址，然后从磁盘读取出来。那么F2FS的文件结构是怎么样的呢?</p>
<p><img src="/img/Artical/f2fs/inode-blockmap.png" alt=""></p>
<p>如上图，F2FS中的一个inode，包含两个主要部分: metadata部分，和数据块寻址部分。我们重点观察数据块寻址部分，分析inode时如何将数据块索引出来。在图中，数据块寻址部分包含direct pointers，single-indirect，double-indirect，以及triple-indirect。它们的含义分别是：</p>
<p><strong>direct pointer:</strong> inode内直接指向数据块(图右上角Data)的地址数组，即<strong>inode-&gt;data模式</strong>。</p>
<p><strong>single-indirect pointer:</strong> inode记录了两个single-indirect pointer(图右上角Direct node)，每一个single-indirect pointer存储了多个数据块的地址，即<strong>inode-&gt;direct_node-&gt;data模式</strong>。</p>
<p><strong>double-indirect:</strong> inode记录了两个double-indirect pointer(图右上角indirect node)，每一个double-indirect pointer记录了许多single-indirect pointer，每一个single-indirect pointer指向了数据块，即<strong>inode-&gt;indirect_node-&gt;direct_node-&gt;data模式</strong>。</p>
<p><strong>triple-indirect:</strong> inode记录了一个triple-indirect pointer(图右上角indirect node)，每一个triple-indirect pointer记录了许多double-indirect pointer，每一个double-indirect pointer记录了许多single-indirect pointer，最后每一个single-indirect pointer指向了数据块。即<strong>inode-&gt;indirect_node-&gt;indirect_node-&gt;direct_node-&gt;data模式</strong>。</p>
<p>因此，我们可以发现，F2FS的inode结构采取indirect_node，首先在inode内部寻找物理地址，如果找不到再去direct_node找，层层深入。</p>
<h3 id="目录结构">目录结构</h3>
<p><img src="/img/Artical/f2fs/dir-entries.jpeg" alt="directory structure"></p>
<h4 id="directory-entry">directory entry</h4>
<p>每个目录 entry 包括 hash / ino / len / type 四个成员，占用 11 bytes。每个 entry 代表一个子目录、符号链接或者普通文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A directory entry occupies 11 bytes, which consists of the following attributes.</span><br><span class="line"> </span><br><span class="line">- hash          hash value of the file name</span><br><span class="line">- ino           inode number</span><br><span class="line">- len           the length of file name</span><br><span class="line">- type          file type such as directory, symlink, etc</span><br></pre></td></tr></table></figure>
<h4 id="directory-block">directory block</h4>
<p>专门存储 directory entry 的 block 叫做 diretory block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A dentry block consists of 214 dentry slots and file names. Therein a bitmap is</span><br><span class="line">used to represent whether each dentry is valid or not. A dentry block occupies</span><br><span class="line">4KB with the following composition.</span><br><span class="line"> </span><br><span class="line">  Dentry Block(4 K) = bitmap (27 bytes) + reserved (3 bytes) +</span><br><span class="line">                      dentries(11 * 214 bytes) + file name (8 * 214 bytes)</span><br><span class="line"> </span><br><span class="line">+--------+----------+----------+------------+</span><br><span class="line">  | bitmap | reserved | dentries | file names |</span><br><span class="line">  +--------+----------+----------+------------+</span><br><span class="line">  [Dentry Block: 4KB] .   .</span><br><span class="line">                 .               .</span><br><span class="line">            .                          .</span><br><span class="line">            +------+------+-----+------+</span><br><span class="line">            | hash | ino  | len | type |</span><br><span class="line">            +------+------+-----+------+</span><br><span class="line">            [Dentry Structure: 11 bytes]</span><br></pre></td></tr></table></figure>
<h4 id="bucket">bucket</h4>
<p>很容易想到目录结构是一系列的哈希表连续地存储在一个文件中，每个哈希表具有一组相当大的 buckets。查找过程从第一个哈希表到下一个哈希表，在每一个阶段对合适的bucket 执行线性查找，直到找到文件名或者查找到最后的那个哈希表。在查找过程中，在合适的 bucket 中的任意空闲空间都会被记录，以防需要创建文件名的时候用到。</p>
<p>F2FS 对目录结构实现了多级哈希表，每一级都有一个使用专用数字的哈希 bucket 的哈希表，如下所示。注意，“A(2B)”表示一个哈希 bucket 包含两个数据块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">A : bucket    哈希bucket</span><br><span class="line">B : block     数据块</span><br><span class="line">N : MAX_DIR_HASH_DEPTH   最大目录哈希层级</span><br><span class="line">----------------------</span><br><span class="line">level #0:   A(2B)</span><br><span class="line">level #1:   A(2B) - A(2B)</span><br><span class="line">level #2:   A(2B) - A(2B) - A(2B) - A(2B)</span><br><span class="line">     .       .       .       .       .</span><br><span class="line">level #N/2:  A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)</span><br><span class="line">     .        .       .       .       .</span><br><span class="line">level #N:   A(4B) - A(4B) - A(4B) - A(4B) - A(4B) - ... - A(4B)</span><br></pre></td></tr></table></figure>
<p><img src="/img/Artical/f2fs/bucket-structure.jpeg" alt="bucket structure"></p>
<p>F2FS 在目录中查找文件名时，首先计算文件名的哈希值，然后在 level #0 中扫描哈希值查找包含文件名和文件的 inode 的目录项。如果没有找到，F2FS在 level #1 中扫描下一个哈希表，用这种方式，F2FS 以递增的方式扫描每个 level 的哈希表（如果上一 level 中没有查找到结果），在每个 level中，F2FS 仅需要扫描一个bucket，而该 bucket 的号是由文件名的哈希值与该 level 中的 buckets 个数的相除取余得到的。也就是每个 level 中需要扫描的一个 bucket 由下式确定的，查找复杂度是 O(log(# of files))</p>
<blockquote>
<p>bucket number to scan in level #n = (hash value) % (# of buckets in level #)</p>
</blockquote>
<h2 id="文件操作流程">文件操作流程</h2>
<h3 id="file-open">file open</h3>
<p>函数调用流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">open sys_call -&gt;</span><br><span class="line">    do_sys_open -&gt;</span><br><span class="line">        do_sys_openat2 -&gt;</span><br><span class="line">            get_unused_fd_flags</span><br><span class="line">            do_filp_open -&gt;</span><br><span class="line">                path_openat -&gt;</span><br><span class="line">                    alloc_empty_file</span><br><span class="line">                    while(</span><br><span class="line">                        link_path_walk</span><br><span class="line">                        open_last_lookups [lookup and maybe create] -&gt;</span><br><span class="line">                            lookup_open -&gt;</span><br><span class="line">                              d_lookup [find dentry in cache]</span><br><span class="line">                              dir_inode-&gt;i_op-&gt;lookup -&gt;</span><br><span class="line">                                  f2fs_lookup</span><br><span class="line">                              dir_inode-&gt;i_op-&gt;create -&gt;</span><br><span class="line">                                  f2fs_create</span><br><span class="line">                    )</span><br><span class="line">                    do_open -&gt;</span><br><span class="line">                        vfs_open -&gt;</span><br><span class="line">                                do_dentry_open -&gt;</span><br><span class="line">                                        f2fs_file_open</span><br><span class="line">            fsnotify_open and fd_install [load fd in cur task_struct]</span><br></pre></td></tr></table></figure>
<p>相关回调函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_create</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="type">nid_t</span> ino = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 inode 实例：kmemcache 分配 inode，且从 freelist 申请 nid</span></span><br><span class="line">        inode = f2fs_new_inode(dir, mode);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!test_opt(sbi, DISABLE_EXT_IDENTIFY))</span><br><span class="line">                <span class="comment">// 创建时为 cold</span></span><br><span class="line">                set_cold_file(sbi, inode, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值 iop fop aop</span></span><br><span class="line">        inode-&gt;i_op = &amp;f2fs_file_inode_operations;</span><br><span class="line">        inode-&gt;i_fop = &amp;f2fs_file_operations;</span><br><span class="line">        inode-&gt;i_mapping-&gt;a_ops = &amp;f2fs_dblock_aops;</span><br><span class="line">        ino = inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联到 dentry</span></span><br><span class="line">        <span class="comment">// 这里会更新 parent metadata</span></span><br><span class="line">        err = f2fs_add_link(dentry, inode);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 sbi 获取 nm_i，并从中关联的 free list 删除对应空间，让给 ino 使用</span></span><br><span class="line">        alloc_nid_done(sbi, ino);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sbi-&gt;por_doing)</span><br><span class="line">                <span class="comment">// VFS 层函数，使用 inode 信息，构造完整的 dentry</span></span><br><span class="line">                d_instantiate(dentry, inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">        clear_nlink(inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">        iput(inode);</span><br><span class="line">        alloc_nid_failed(sbi, ino);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 inode：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">f2fs_new_inode</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line">        <span class="type">nid_t</span> ino;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="type">bool</span> nid_free = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VFS 函数，通过 kmalloc 返回 inode 实例</span></span><br><span class="line">        <span class="comment">// 内部会调用 s_op-&gt;alloc_inode() 进行初始化</span></span><br><span class="line">        <span class="comment">// 对应到 F2FS 就是 f2fs_alloc_inode()</span></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        <span class="keyword">if</span> (!inode)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, NODE_NEW);</span><br><span class="line">        <span class="comment">// 分配 inode 号，后续存放于 inode-&gt;i_ino，也就是 node id</span></span><br><span class="line">        <span class="keyword">if</span> (!alloc_nid(sbi, &amp;ino)) &#123;</span><br><span class="line">                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                err = -ENOSPC;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_uid = current_fsuid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dir-&gt;i_mode &amp; S_ISGID) &#123;</span><br><span class="line">                inode-&gt;i_gid = dir-&gt;i_gid;</span><br><span class="line">                <span class="keyword">if</span> (S_ISDIR(mode))</span><br><span class="line">                        mode |= S_ISGID;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inode-&gt;i_gid = current_fsgid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_ino = ino;</span><br><span class="line">        inode-&gt;i_mode = mode;</span><br><span class="line">        inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_generation = sbi-&gt;s_next_generation++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 VFS 层的函数</span></span><br><span class="line">        <span class="comment">// inode 插入到 VFS 层私有的 inode_hashtable，自身关联 inode-&gt;i_hash</span></span><br><span class="line">        <span class="comment">// 这样以后可以在内存中通过 inode 号快速查找到 inode</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// 区分 inode number（ino）和 node number（nid）</span></span><br><span class="line">        <span class="comment">// inode number 是 VFS 可以访问的，我个人理解是一个 file 对应一个 inode number</span></span><br><span class="line">        <span class="comment">// 但是 F2FS 是维护 node number 来完成寻址（用一个 ID 来替代绝对地址，解决 wandering tree）</span></span><br><span class="line">        <span class="comment">// 因此只要需要寻址的 node block 都会有一个 nid（相比之下 data block 不需要 nid）</span></span><br><span class="line">        <span class="comment">// 这里的交集在于 ino 的分配也是通过 nid 得到的（见上方，alloc_nid(..., &amp;ino)）</span></span><br><span class="line">        <span class="comment">// nid == ino 表明这是一个 inode，反之则表示是一个 direct_node 或者 indirect_node</span></span><br><span class="line">        err = insert_inode_locked(inode);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                err = -EINVAL;</span><br><span class="line">                nid_free = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记脏页，以后回写</span></span><br><span class="line">        mark_inode_dirty(inode);</span><br><span class="line">        <span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        clear_nlink(inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">fail:</span><br><span class="line">        iput(inode);</span><br><span class="line">        <span class="keyword">if</span> (nid_free)</span><br><span class="line">                alloc_nid_failed(sbi, ino);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，f2fs_new_inode() 有以下流程：</p>
<ol>
<li>通过 VFS 层 new_inode() 通过 kmalloc 获得 inode 实例</li>
<li>填充必要的具体文件系统参数到 inode</li>
<li>alloc_nid() 分配 inode-&gt;ino</li>
<li>inode 插入到 VFS 层私有的 inode_hashtable，自身关联 inode-&gt;i_hash</li>
<li>标记 inode 为 dirty</li>
<li>返回 inode 实例</li>
</ol>
<p>分配 nid：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this function returns success, caller can obtain a new nid</span></span><br><span class="line"><span class="comment"> * from second parameter of this function.</span></span><br><span class="line"><span class="comment"> * The returned nid could be used ino as well as nid when inode is created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">alloc_nid</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">nid_t</span> *nid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">free_nid</span> *<span class="title">i</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">retry:</span><br><span class="line">        mutex_lock(&amp;nm_i-&gt;build_lock);</span><br><span class="line">        <span class="comment">// fcnt 含义：the number of free node id</span></span><br><span class="line">        <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                <span class="comment">/* scan NAT in order to build free nid list */</span></span><br><span class="line">                <span class="comment">// 没有 free node 就需要需要通过 NAT 构建</span></span><br><span class="line">                build_free_nids(sbi);</span><br><span class="line">                <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                        mutex_unlock(&amp;nm_i-&gt;build_lock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;nm_i-&gt;build_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We check fcnt again since previous check is racy as</span></span><br><span class="line"><span class="comment">         * we didn&#x27;t hold free_nid_list_lock. So other thread</span></span><br><span class="line"><span class="comment">         * could consume all of free nids.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">        <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                spin_unlock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BUG_ON(list_empty(&amp;nm_i-&gt;free_nid_list));</span><br><span class="line">        <span class="comment">// 遍历 freelist 查找 free_nid</span></span><br><span class="line">        list_for_each(this, &amp;nm_i-&gt;free_nid_list) &#123;</span><br><span class="line">                i = list_entry(this, <span class="keyword">struct</span> free_nid, <span class="built_in">list</span>);</span><br><span class="line">                <span class="comment">// 用了这个 i，后续 i-&gt;state 改为 NID_ALLOC</span></span><br><span class="line">                <span class="keyword">if</span> (i-&gt;state == NID_NEW)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BUG_ON(i-&gt;state != NID_NEW);</span><br><span class="line">        *nid = i-&gt;nid;</span><br><span class="line">        i-&gt;state = NID_ALLOC;</span><br><span class="line">        nm_i-&gt;fcnt--;</span><br><span class="line">        spin_unlock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nid freelist 不一定是完整的，当 free nid 不够了的时候就会重新进行构建。</p>
<p>关联 dentry，通过特定的哈希算法定位并初始化 dentry，更新 parent inode 的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_add_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> bit_pos;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> current_depth;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bidx, block;</span><br><span class="line">        <span class="type">f2fs_hash_t</span> dentry_hash;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nbucket, nblock;</span><br><span class="line">        <span class="comment">// parent directory 对应的 inode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(dir-&gt;i_sb);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name = dentry-&gt;d_name.name;</span><br><span class="line">        <span class="type">size_t</span> namelen = dentry-&gt;d_name.len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">dentry_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dentry_block</span> *<span class="title">dentry_blk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// #define GET_DENTRY_SLOTS(x)  ((x + F2FS_NAME_LEN - 1) &gt;&gt; F2FS_NAME_LEN_BITS)</span></span><br><span class="line">        <span class="type">int</span> slots = GET_DENTRY_SLOTS(namelen);</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 filename 作为 hash key</span></span><br><span class="line">        dentry_hash = f2fs_dentry_hash(name, dentry-&gt;d_name.len);</span><br><span class="line">        level = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录能到达的最高 depth</span></span><br><span class="line">        current_depth = F2FS_I(dir)-&gt;i_current_depth;</span><br><span class="line">        <span class="comment">// 如果和最近访问的文件哈希冲突，重置最近访问文件的 hash 并从最近访问文件的 level 开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (F2FS_I(dir)-&gt;chash == dentry_hash) &#123;</span><br><span class="line">                level = F2FS_I(dir)-&gt;clevel;</span><br><span class="line">                F2FS_I(dir)-&gt;chash = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到多级哈希表的查找过程</span></span><br><span class="line">start:</span><br><span class="line">        <span class="keyword">if</span> (current_depth == MAX_DIR_HASH_DEPTH)</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase the depth, if required */</span></span><br><span class="line">        <span class="keyword">if</span> (level == current_depth)</span><br><span class="line">                ++current_depth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按公式计算 bucket 数目</span></span><br><span class="line">        nbucket = dir_buckets(level);</span><br><span class="line">        <span class="comment">// 计算 block 数目</span></span><br><span class="line">        nblock = bucket_blocks(level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位 block index</span></span><br><span class="line">        bidx = dir_block_index(level, (le32_to_cpu(dentry_hash) % nbucket));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前 bucket 中遍历 block</span></span><br><span class="line">        <span class="keyword">for</span> (block = bidx; block &lt;= (bidx + nblock - <span class="number">1</span>); block++) &#123;</span><br><span class="line">                mutex_lock_op(sbi, DENTRY_OPS);</span><br><span class="line">                <span class="comment">// 为 index = block 分配对应的 data page</span></span><br><span class="line">                dentry_page = get_new_data_page(dir, block, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(dentry_page)) &#123;</span><br><span class="line">                        mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">                        <span class="keyword">return</span> PTR_ERR(dentry_page);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 临时映射</span></span><br><span class="line">                <span class="comment">// 往 dentry_blk 写入数据，然后对 dentry_page 标记 dirty 就能刷入外存</span></span><br><span class="line">                dentry_blk = kmap(dentry_page);</span><br><span class="line">                bit_pos = room_for_filename(dentry_blk, slots);</span><br><span class="line">                <span class="comment">// NR_DENTRY_IN_BLOCK = 214，一个 dentry block 含有 214 个 dentry slot</span></span><br><span class="line">                <span class="keyword">if</span> (bit_pos &lt; NR_DENTRY_IN_BLOCK)</span><br><span class="line">                        <span class="comment">// 定位成功，挑出循环</span></span><br><span class="line">                        <span class="keyword">goto</span> add_dentry;</span><br><span class="line"></span><br><span class="line">                kunmap(dentry_page);</span><br><span class="line">                f2fs_put_page(dentry_page, <span class="number">1</span>);</span><br><span class="line">                mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move to next level to find the empty slot for new dentry */</span></span><br><span class="line">        <span class="comment">// 失败定位，继续循环走更高层</span></span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">goto</span> start;</span><br><span class="line"><span class="comment">// 定位成功</span></span><br><span class="line">add_dentry:</span><br><span class="line">        <span class="comment">// 提供 inode 对应的 page（通用函数 grab_cache_page()）和对应的 aops</span></span><br><span class="line">        err = init_inode_metadata(inode, dentry);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        wait_on_page_writeback(dentry_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dentry</span></span><br><span class="line">        de = &amp;dentry_blk-&gt;dentry[bit_pos];</span><br><span class="line">        de-&gt;hash_code = dentry_hash;</span><br><span class="line">        de-&gt;name_len = cpu_to_le16(namelen);</span><br><span class="line">        <span class="built_in">memcpy</span>(dentry_blk-&gt;filename[bit_pos], name, namelen);</span><br><span class="line">        de-&gt;ino = cpu_to_le32(inode-&gt;i_ino);</span><br><span class="line">        set_de_type(de, inode);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; slots; i++)</span><br><span class="line">                test_and_set_bit_le(bit_pos + i, &amp;dentry_blk-&gt;dentry_bitmap);</span><br><span class="line">        set_page_dirty(dentry_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dir 是 parent inode</span></span><br><span class="line">        <span class="comment">// 更新 dir 与之关联的信息</span></span><br><span class="line">        update_parent_metadata(dir, inode, current_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update parent inode number before releasing dentry page */</span></span><br><span class="line">        F2FS_I(inode)-&gt;i_pino = dir-&gt;i_ino;</span><br><span class="line">fail:</span><br><span class="line">        kunmap(dentry_page);</span><br><span class="line">        f2fs_put_page(dentry_page, <span class="number">1</span>);</span><br><span class="line">        mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>f2fs_lookup 中也实现了上述的流程。（实际上我看的更新的内核版本，目录项查找流程已经写进 __f2fs_find_entry 函数里了）</p>
<h3 id="write-operation">write operation</h3>
<p>f2fs 在 vfs 的注册函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">f2fs_file_operations</span> =</span> &#123;</span><br><span class="line">        .write          = do_sync_write,</span><br><span class="line">        .aio_write      = generic_file_aio_write,</span><br><span class="line">        .splice_write   = generic_file_splice_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">f2fs_dblock_aops</span> =</span> &#123;</span><br><span class="line">        .writepage      = f2fs_write_data_page,</span><br><span class="line">        .writepages     = f2fs_write_data_pages,</span><br><span class="line">        .write_begin    = f2fs_write_begin,</span><br><span class="line">        .write_end      = nobh_write_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>f2fs_write_begin()</code> 为写入操作准备了 page，并通过 <code>pagep</code> 指向它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_begin</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                <span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">pgoff_t</span> index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) pos) &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> <span class="title">dn</span>;</span></span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* for nobh_write_end */</span></span><br><span class="line">        *fsdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 相关</span></span><br><span class="line">        f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化要写的 page（Find or create a page at the given pagecache position）</span></span><br><span class="line">        <span class="comment">// 这里保证存在于 page cache 中</span></span><br><span class="line">        page = grab_cache_page_write_begin(mapping, index, flags);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        *pagep = page;</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, DATA_NEW);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dnode，用于找到物理地址（data_blkaddr）</span></span><br><span class="line">        set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        err = get_dnode_of_data(&amp;dn, index, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line">                f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dn.data_blkaddr == NULL_ADDR) &#123;</span><br><span class="line">                err = reserve_new_block(&amp;dn);</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        f2fs_put_dnode(&amp;dn);</span><br><span class="line">                        mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_dnode(&amp;dn);</span><br><span class="line"></span><br><span class="line">        mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((len == PAGE_CACHE_SIZE) || PageUptodate(page))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pos &amp; PAGE_CACHE_MASK) &gt;= i_size_read(inode)) &#123;</span><br><span class="line">                <span class="type">unsigned</span> start = pos &amp; (PAGE_CACHE_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="type">unsigned</span> end = start + len;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Reading beyond i_size is simple: memset to zero */</span></span><br><span class="line">                zero_user_segments(page, <span class="number">0</span>, start, end, PAGE_CACHE_SIZE);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append 操作</span></span><br><span class="line">        <span class="keyword">if</span> (dn.data_blkaddr == NEW_ADDR) &#123;</span><br><span class="line">                <span class="comment">// 填 0</span></span><br><span class="line">                zero_user_segment(page, <span class="number">0</span>, PAGE_CACHE_SIZE);</span><br><span class="line">        <span class="comment">// overwrite 操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 读出旧的内容</span></span><br><span class="line">                err = f2fs_readpage(sbi, page, dn.data_blkaddr, READ_SYNC);</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SetPageUptodate(page);</span><br><span class="line">        clear_cold_data(page);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>f2fs_write_begin() 这个过程会被 VFS 调用，然后得到 page 的 VFS 将 write(fd, buf, size) 需要写入的 buf 内容拷贝到该 page。VFS 拷贝完成后，还会调用 write_end() 作为写入操作的结束调用，主要是为此前已上锁的 page 进行解锁</p>
<p>普通文件的默认写策略是 writeback，VFS 通过提供 writepage() 等定制点来实现具体文件系统的写回操作。前面已提到 F2FS 使用 f2fs_write_data_page() 和 f2fs_write_data_pages() 来完成这个操作</p>
<p>写回线程的调用路径：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bdi_writeback_thread</span><br><span class="line">  wb_do_writeback</span><br><span class="line">    wb_writeback</span><br><span class="line">      __writeback_single_inode</span><br><span class="line">        do_writepages</span><br><span class="line">          a_ops-&gt;writepages</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_data_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> writeback_control *wbc)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="type">loff_t</span> i_size = i_size_read(inode);</span><br><span class="line">        <span class="type">const</span> <span class="type">pgoff_t</span> end_index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) i_size) &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">        <span class="type">unsigned</span> offset;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;index &lt; end_index)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the offset is out-of-range of file size,</span></span><br><span class="line"><span class="comment">         * this page does not have to be written to disk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 找到要写的地方</span></span><br><span class="line">        offset = i_size &amp; (PAGE_CACHE_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((page-&gt;index &gt;= end_index + <span class="number">1</span>) || !offset) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                        dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                        inode_dec_dirty_dents(inode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> unlock_out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [offset, SIZE) 先清零</span></span><br><span class="line">        zero_user_segment(page, offset, PAGE_CACHE_SIZE);</span><br><span class="line">out:</span><br><span class="line">        <span class="comment">// 如果正在做 recovery，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;por_doing)</span><br><span class="line">                <span class="keyword">goto</span> redirty_out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// writeback controller 的特性</span></span><br><span class="line">        <span class="comment">// for_reclaim 在 shrink_page_list() 中被置为 1</span></span><br><span class="line">        <span class="comment">// 也就是说内存吃紧且高频数据可能被跳过</span></span><br><span class="line">        <span class="keyword">if</span> (wbc-&gt;for_reclaim &amp;&amp; !S_ISDIR(inode-&gt;i_mode) &amp;&amp; !is_cold_data(page))</span><br><span class="line">                <span class="keyword">goto</span> redirty_out;</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, DATA_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                inode_dec_dirty_dents(inode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际的写操作</span></span><br><span class="line">        err = do_write_data_page(page);</span><br><span class="line">        <span class="comment">// 有问题就下次再来</span></span><br><span class="line">        <span class="keyword">if</span> (err &amp;&amp; err != -ENOENT) &#123;</span><br><span class="line">                wbc-&gt;pages_skipped++;</span><br><span class="line">                set_page_dirty(page);</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock_op(sbi, DATA_WRITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wbc-&gt;for_reclaim)</span><br><span class="line">                f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == -ENOENT)</span><br><span class="line">                <span class="keyword">goto</span> unlock_out;</span><br><span class="line"></span><br><span class="line">        clear_cold_data(page);</span><br><span class="line">        unlock_page(page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!wbc-&gt;for_reclaim &amp;&amp; !S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">                f2fs_balance_fs(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock_out:</span><br><span class="line">        unlock_page(page);</span><br><span class="line">        <span class="keyword">return</span> (err == -ENOENT) ? <span class="number">0</span> : err;</span><br><span class="line"></span><br><span class="line">redirty_out:</span><br><span class="line">        wbc-&gt;pages_skipped++;</span><br><span class="line">        set_page_dirty(page);</span><br><span class="line">        <span class="keyword">return</span> AOP_WRITEPAGE_ACTIVATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>struct dnode_of_data</code> 是寻址用到的数据结构，用于物理地址寻址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this structure is used as one of function parameters.</span></span><br><span class="line"><span class="comment"> * all the information are dedicated to a given direct node block determined</span></span><br><span class="line"><span class="comment"> * by the data offset in a file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span>            <span class="comment">/* vfs inode pointer */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">inode_page</span>;</span>        <span class="comment">/* its inode page, NULL is possible */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_page</span>;</span>         <span class="comment">/* cached direct node page */</span></span><br><span class="line">        <span class="type">nid_t</span> nid;                      <span class="comment">/* node id of the direct node block */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node;       <span class="comment">/* data offset in the node page */</span></span><br><span class="line">        <span class="type">bool</span> inode_page_locked;         <span class="comment">/* inode page is locked or not */</span></span><br><span class="line">        <span class="type">block_t</span> data_blkaddr;           <span class="comment">/* block address of the node block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_new_dnode</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page *ipage, <span class="keyword">struct</span> page *npage, <span class="type">nid_t</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dn, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dn));</span><br><span class="line">        dn-&gt;inode = inode;</span><br><span class="line">        dn-&gt;inode_page = ipage;</span><br><span class="line">        dn-&gt;node_page = npage;</span><br><span class="line">        dn-&gt;nid = nid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Caller should call f2fs_put_dnode(dn).</span></span><br><span class="line"><span class="comment">        早期版本代码，仅供理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_dnode_of_data</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="type">pgoff_t</span> index, <span class="type">int</span> ro)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(dn-&gt;inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">npage</span>[4];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">parent</span>;</span></span><br><span class="line">        <span class="type">int</span> offset[<span class="number">4</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> noffset[<span class="number">4</span>];</span><br><span class="line">        <span class="type">nid_t</span> nids[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> level, i;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心 block 寻址，callee 传回 offset[]</span></span><br><span class="line">        <span class="comment">// 得到 node 层数 level，每层的数组下标偏移 offset 和 依次排列的第几个 node 的 noffset</span></span><br><span class="line">        level = get_node_path(index, offset, noffset);</span><br><span class="line"></span><br><span class="line">        nids[<span class="number">0</span>] = dn-&gt;inode-&gt;i_ino;</span><br><span class="line">        <span class="comment">// 途径 get_node_page -&gt; read_node_page -&gt; f2fs_readpage</span></span><br><span class="line">        <span class="comment">// 读到了 inode page</span></span><br><span class="line">        npage[<span class="number">0</span>] = get_node_page(sbi, nids[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(npage[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(npage[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是 inode page</span></span><br><span class="line">        parent = npage[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 使用 page 和 offset 计算出 nid</span></span><br><span class="line">        <span class="comment">// 返回 (struct f2fs_node*) page_address(parent)-&gt;i.i_nid[offset[0] - NODE_DIR1_BLOCK]</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// f2fs_node 可以表现 3 种形式：inode, direct, and indirect types。这里是 inode（-&gt;i）</span></span><br><span class="line">        <span class="comment">// i_nid[5] 存放 direct(2) + indirect(2) + d_indirect(2) 的 node id</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 但这里为什么如此确定 offset[0] &gt;= NODE_DIR1_BLOCK？</span></span><br><span class="line">        <span class="comment">// 看了后期的代码是需要判断的（if level&gt;0），这里早期实现确实是个 bug</span></span><br><span class="line">        nids[<span class="number">1</span>] = get_nid(parent, offset[<span class="number">0</span>], <span class="literal">true</span>);</span><br><span class="line">        dn-&gt;inode_page = npage[<span class="number">0</span>];</span><br><span class="line">        dn-&gt;inode_page_locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get indirect or direct nodes */</span></span><br><span class="line">        <span class="comment">// 总之这里就按层级不断读页</span></span><br><span class="line">        <span class="comment">// 一些实现细节：</span></span><br><span class="line">        <span class="comment">// - 如果遇到没有 nid 的 block，那就分配（内存没有读上来？）</span></span><br><span class="line">        <span class="comment">// - page 会尝试预读（ro == true</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= level; i++) &#123;</span><br><span class="line">                <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!nids[i] &amp;&amp; !ro) &#123;</span><br><span class="line">                        mutex_lock_op(sbi, NODE_NEW);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* alloc new node */</span></span><br><span class="line">                        <span class="keyword">if</span> (!alloc_nid(sbi, &amp;(nids[i]))) &#123;</span><br><span class="line">                                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                                err = -ENOSPC;</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dn-&gt;nid = nids[i];</span><br><span class="line">                        <span class="comment">// 从 page cache 获取 page，如果没有对应 page，允许读页</span></span><br><span class="line">                        npage[i] = new_node_page(dn, noffset[i]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                alloc_nid_failed(sbi, nids[i]);</span><br><span class="line">                                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新 parent-&gt;i.i_nid[] (if i==1) 或者 parent-&gt;in.nid[] (if i != 1)</span></span><br><span class="line">                        set_nid(parent, offset[i - <span class="number">1</span>], nids[i], i == <span class="number">1</span>);</span><br><span class="line">                        alloc_nid_done(sbi, nids[i]);</span><br><span class="line">                        mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ro &amp;&amp; i == level &amp;&amp; level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        npage[i] = get_node_page_ra(parent, offset[i - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                        dn-&gt;inode_page_locked = <span class="literal">false</span>;</span><br><span class="line">                        unlock_page(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f2fs_put_page(parent, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">                        npage[i] = get_node_page(sbi, nids[i]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                f2fs_put_page(npage[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                                <span class="keyword">goto</span> release_out;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; level) &#123;</span><br><span class="line">                        parent = npage[i];</span><br><span class="line">                        nids[i + <span class="number">1</span>] = get_nid(parent, offset[i], <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是会写入到 summary entry 的 nid，也就是 parent node</span></span><br><span class="line">        <span class="comment">// 比如 direct pointer（level==0）的情况，这里就填入 ino</span></span><br><span class="line">        dn-&gt;nid = nids[level];</span><br><span class="line">        <span class="comment">// 块内偏移</span></span><br><span class="line">        dn-&gt;ofs_in_node = offset[level];</span><br><span class="line">        dn-&gt;node_page = npage[level];</span><br><span class="line">        <span class="comment">// 最终目标，知道第几层，哪个 page 以及 offset 后，对着数据结构布局解析就能得到</span></span><br><span class="line">        dn-&gt;data_blkaddr = datablock_addr(dn-&gt;node_page, dn-&gt;ofs_in_node);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">release_pages:</span><br><span class="line">        f2fs_put_page(parent, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">                f2fs_put_page(npage[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">release_out:</span><br><span class="line">        dn-&gt;inode_page = <span class="literal">NULL</span>;</span><br><span class="line">        dn-&gt;node_page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>F2FS 的 writeback 实际靠 do_write_data_page 完成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_write_data_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="type">block_t</span> old_blk_addr, new_blk_addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> <span class="title">dn</span>;</span></span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻址过程，得到 old_blk_addr</span></span><br><span class="line">        set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        err = get_dnode_of_data(&amp;dn, page-&gt;index, RDONLY_NODE);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        old_blk_addr = dn.data_blkaddr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This page is already truncated */</span></span><br><span class="line">        <span class="keyword">if</span> (old_blk_addr == NULL_ADDR)</span><br><span class="line">                <span class="keyword">goto</span> out_writepage;</span><br><span class="line"></span><br><span class="line">        set_page_writeback(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If current allocation needs SSR,</span></span><br><span class="line"><span class="comment">         * it had better in-place writes for updated data.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// SSR-style 写操作</span></span><br><span class="line">        <span class="comment">// SSR 指的是 Slack Space Recycling</span></span><br><span class="line">        <span class="comment">// 含义见 f2fs/segment.h，reuses obsolete space without cleaning operations</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 也就是说这里是 in-place update</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 需要的条件 need_inplace_update() 如论文描述，</span></span><br><span class="line">        <span class="comment">// free section 数目（由 free_i 维护）少于一定阈值时满足</span></span><br><span class="line">        <span class="keyword">if</span> (old_blk_addr != NEW_ADDR &amp;&amp; !is_cold_data(page) &amp;&amp;</span><br><span class="line">                                need_inplace_update(inode)) &#123;</span><br><span class="line">                rewrite_data_page(F2FS_SB(inode-&gt;i_sb), page,</span><br><span class="line">                                                old_blk_addr);</span><br><span class="line">        <span class="comment">// 而这里是 LFS-style 的写操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write_data_page(inode, page, &amp;dn,</span><br><span class="line">                                old_blk_addr, &amp;new_blk_addr);</span><br><span class="line">                update_extent_cache(new_blk_addr, &amp;dn);</span><br><span class="line">                F2FS_I(inode)-&gt;data_version =</span><br><span class="line">                        le64_to_cpu(F2FS_CKPT(sbi)-&gt;checkpoint_ver);</span><br><span class="line">        &#125;</span><br><span class="line">out_writepage:</span><br><span class="line">        f2fs_put_dnode(&amp;dn);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际的写操作是区分为原地写和追加写</p>
<p>In-place write：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewrite_data_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                                        <span class="type">block_t</span> old_blk_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">        submit_write_page(sbi, page, old_blk_addr, DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_write_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                                <span class="type">block_t</span> blk_addr, <span class="keyword">enum</span> page_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bdev</span> =</span> sbi-&gt;sb-&gt;s_bdev;</span><br><span class="line"></span><br><span class="line">        verify_block_addr(sbi, blk_addr);</span><br><span class="line"></span><br><span class="line">        down_write(&amp;sbi-&gt;bio_sem);</span><br><span class="line"></span><br><span class="line">        inc_page_count(sbi, F2FS_WRITEBACK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// super block 维护 DATA/NODE/META 类型的 bio[] 数组</span></span><br><span class="line">        <span class="comment">// last_block_in_bio[] 表示最后的 block 号</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[type] &amp;&amp; sbi-&gt;last_block_in_bio[type] != blk_addr - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 不连续的 page 先提交上去</span></span><br><span class="line">                <span class="comment">// false 指的是异步提交，如果是 true 则是 SYNC</span></span><br><span class="line">                <span class="comment">// 在这个上下文中，内部大概是一个 submit_bio() 的封装</span></span><br><span class="line">                do_submit_bio(sbi, type, <span class="literal">false</span>);</span><br><span class="line">alloc_new:</span><br><span class="line">        <span class="comment">// 既然没在 sbi 初始化过程找到它的身影，那就是默认为 NULL，先分配</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 提交（submit_bio()）后，bio 也是回归到 NULL。因此上面不连续的提交后也走这个分支</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[type] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 1. kmemcache 分配 f2fs 私有数据结构 struct bio_private，用于 check point 等待唤醒</span></span><br><span class="line">                <span class="comment">// 2. 使用内核通用的 bio_alloc() 分配 bio</span></span><br><span class="line">                sbi-&gt;bio[type] = f2fs_bio_alloc(bdev, bio_get_nr_vecs(bdev));</span><br><span class="line">                sbi-&gt;bio[type]-&gt;bi_sector = SECTOR_FROM_BLOCK(sbi, blk_addr);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The end_io will be assigned at the sumbission phase.</span></span><br><span class="line"><span class="comment">                 * Until then, let bio_add_page() merge consecutive IOs as much</span></span><br><span class="line"><span class="comment">                 * as possible.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bio 合并 page</span></span><br><span class="line">        <span class="keyword">if</span> (bio_add_page(sbi-&gt;bio[type], page, PAGE_CACHE_SIZE, <span class="number">0</span>) &lt;</span><br><span class="line">                                                        PAGE_CACHE_SIZE) &#123;</span><br><span class="line">                do_submit_bio(sbi, type, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">goto</span> alloc_new;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 last block，尽可能合并提交</span></span><br><span class="line">        sbi-&gt;last_block_in_bio[type] = blk_addr;</span><br><span class="line"></span><br><span class="line">        up_write(&amp;sbi-&gt;bio_sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_submit_bio</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                <span class="keyword">enum</span> page_type type, <span class="type">bool</span> sync)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rw = sync ? WRITE_SYNC : WRITE;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">page_type</span> <span class="title">btype</span> =</span> type &gt; META ? META : type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type &gt;= META_FLUSH)</span><br><span class="line">                rw = WRITE_FLUSH_FUA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[btype]) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">bio_private</span> *<span class="title">p</span> =</span> sbi-&gt;bio[btype]-&gt;bi_private;</span><br><span class="line">                p-&gt;sbi = sbi;</span><br><span class="line">                <span class="comment">// 完成后的回调</span></span><br><span class="line">                <span class="comment">// 大概是标记 writeback page 结束，以及处理 check point 细节（唤醒）</span></span><br><span class="line">                sbi-&gt;bio[btype]-&gt;bi_end_io = f2fs_end_io_write;</span><br><span class="line">                <span class="comment">// check point 操作才会有这个类型</span></span><br><span class="line">                <span class="keyword">if</span> (type == META_FLUSH) &#123;</span><br><span class="line">                        DECLARE_COMPLETION_ONSTACK(wait);</span><br><span class="line">                        p-&gt;is_sync = <span class="literal">true</span>;</span><br><span class="line">                        p-&gt;wait = &amp;wait;</span><br><span class="line">                        submit_bio(rw, sbi-&gt;bio[btype]);</span><br><span class="line">                        wait_for_completion(&amp;wait);</span><br><span class="line">                <span class="comment">// 其它类型就是一个 submit_bio() 过程</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p-&gt;is_sync = <span class="literal">false</span>;</span><br><span class="line">                        submit_bio(rw, sbi-&gt;bio[btype]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 提交完后对应 bio 就置空</span></span><br><span class="line">                sbi-&gt;bio[btype] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Append write</p>
<p>在追加写中，new_blkaddr 是由 callee 而非 caller 指定的，因此执行过程后调用方才能得知新的追加地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_data_page</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> dnode_of_data *dn, <span class="type">block_t</span> old_blkaddr,</span></span><br><span class="line"><span class="params">                <span class="type">block_t</span> *new_blkaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">sum</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node_info</span> <span class="title">ni</span>;</span></span><br><span class="line"></span><br><span class="line">        BUG_ON(old_blkaddr == NULL_ADDR);</span><br><span class="line">        get_node_info(sbi, dn-&gt;nid, &amp;ni);</span><br><span class="line">        <span class="comment">// 初始化 summary entry</span></span><br><span class="line">        set_summary(&amp;sum, dn-&gt;nid, dn-&gt;ofs_in_node, ni.version);</span><br><span class="line"></span><br><span class="line">        do_write_page(sbi, page, old_blkaddr,</span><br><span class="line">                        new_blkaddr, &amp;sum, DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_summary</span><span class="params">(<span class="keyword">struct</span> f2fs_summary *sum, <span class="type">nid_t</span> nid,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node, <span class="type">unsigned</span> <span class="type">char</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">        sum-&gt;nid = cpu_to_le32(nid);</span><br><span class="line">        sum-&gt;ofs_in_node = cpu_to_le16(ofs_in_node);</span><br><span class="line">        sum-&gt;version = version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_write_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                        <span class="type">block_t</span> old_blkaddr, <span class="type">block_t</span> *new_blkaddr,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> f2fs_summary *sum, <span class="keyword">enum</span> page_type p_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> old_cursegno;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回诸如 CURSEG_HOT_DATA 等类型</span></span><br><span class="line">        type = __get_segment_type(page, p_type);</span><br><span class="line">        <span class="comment">// 通过 SM_I(sbi)-&gt;curseg_array + type 得到</span></span><br><span class="line">        curseg = CURSEG_I(sbi, type);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line">        <span class="comment">// #define NEXT_FREE_BLKADDR(sbi, curseg) \</span></span><br><span class="line"><span class="comment">        //      (START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff)</span></span><br><span class="line">        <span class="comment">// next_blkoff 决定新的地址</span></span><br><span class="line">        *new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line">        old_cursegno = curseg-&gt;segno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * __add_sum_entry should be resided under the curseg_mutex</span></span><br><span class="line"><span class="comment">         * because, this function updates a summary entry in the</span></span><br><span class="line"><span class="comment">         * current summary block.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// curseg-&gt;sum_blk + next_blkoff*sizeof(f2fs_summary) 后面 memcpy 拼接 sum</span></span><br><span class="line">        __add_sum_entry(sbi, type, sum, curseg-&gt;next_blkoff);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        <span class="comment">// 简单来说，如果是 LFS-style 的话，更新 next 就是简单 +1</span></span><br><span class="line">        <span class="comment">// SSR-style 感兴趣自己看吧</span></span><br><span class="line">        __refresh_next_blkoff(sbi, curseg);</span><br><span class="line">        <span class="comment">// alloc_type: 枚举值，LFS 或者 SSR</span></span><br><span class="line">        sbi-&gt;block_count[curseg-&gt;alloc_type]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * SIT information should be updated before segment allocation,</span></span><br><span class="line"><span class="comment">         * since SSR needs latest valid block information.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 更新 SIT，主要维护对应 segment entry 的 bitmap</span></span><br><span class="line">        refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子函数判断 curseg-&gt;next_blkoff &lt; sbi-&gt;blocks_per_seg</span></span><br><span class="line">        <span class="comment">// 在 1 个 segment 内分配是有极限的。要想超越极限，那就用 2 个 semgnet</span></span><br><span class="line">        <span class="keyword">if</span> (!__has_curseg_space(sbi, type))</span><br><span class="line">                sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        locate_dirty_segment(sbi, old_cursegno);</span><br><span class="line">        locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));</span><br><span class="line">        mutex_unlock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p_type == NODE)</span><br><span class="line">                fill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* writeout dirty page into bdev */</span></span><br><span class="line">        <span class="comment">// 殊途同归，这个过程在 In-place write 已经分析过</span></span><br><span class="line">        submit_write_page(sbi, page, *new_blkaddr, p_type);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="read-operation">read operation</h3>
<p>F2FS的读流程包含了以下几个子流程:</p>
<ol>
<li>vfs_read 函数</li>
<li>generic_file_read_iter 函数: 根据访问类型执行不同的处理</li>
<li>generic_file_buffered_read: 根据用户传入的文件偏移，读取尺寸等信息，计算起始位置和页数，然后遍历每一个 page，通过预读或者单个读取的方式从磁盘中读取出来</li>
<li>f2fs_read_data_page &amp; f2fs_read_data_pages 函数: 从磁盘读取1个 page 或者多个 page</li>
<li>f2fs_mpage_readpages 函数: f2fs 读取数据的主流程</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_page</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="type">int</span> ret = -EAGAIN;</span><br><span class="line"></span><br><span class="line">        trace_f2fs_readpage(page, DATA);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件使用特定的读取方法，这里暂不分析</span></span><br><span class="line">                ret = f2fs_read_inline_data(inode, page);</span><br><span class="line">        ret = f2fs_mpage_readpages(page-&gt;mapping, <span class="literal">NULL</span>, page, <span class="number">1</span>); <span class="comment">// 读取1个page</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_pages</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> list_last_entry(pages, <span class="keyword">struct</span> page, lru);</span><br><span class="line"></span><br><span class="line">        trace_f2fs_readpages(inode, page, nr_pages);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件是size小于1个page的文件，因此不需要进行预读，直接return 0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f2fs_mpage_readpages(mapping, pages, <span class="literal">NULL</span>, nr_pages); <span class="comment">// 读取nr_pages个page</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数表示一个链表头，这个链表保存了多个page，因此需要写入多个page的时候，就要传入一个List。 第三个参数表示单个page，在写入单个page的时候，通过这个函数写入。 第四个参数表示需要写入page的数目。</p>
<p>因此 在写入多个page的时候，需要设定第二个参数，和第四个参数，然后设定第三个参数为NULL。 在写入单个page的时候，需要设定第三个参数，和第四个参数，然后设定第二个参数为NULL。</p>
<p>然后分析这个函数的执行流程:</p>
<ol>
<li>遍历传入的page，得到每一个page的index以及inode</li>
<li>将page的inode以及index传入 f2fs_map_blocks 函数获取到该page的物理地址</li>
<li>将物理地址通过 submit_bio 读取该page在磁盘中的数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_mpage_readpages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> list_head *pages, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 主流程第一步 初始化map结构，这个步骤非常重要，用于获取page在磁盘的物理地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_map_blocks</span> <span class="title">map</span>;</span></span><br><span class="line">        <span class="built_in">map</span>.m_pblk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_lblk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_next_pgofs = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主流程第二步 开始进行遍历，结束条件为 nr_pages 不为空</span></span><br><span class="line">        <span class="keyword">for</span> (page_idx = <span class="number">0</span>; nr_pages; page_idx++, nr_pages--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第一步，如果是读取多个page，则pages不为空，从list里面读取每一次的page结构</span></span><br><span class="line">                <span class="keyword">if</span> (pages) &#123;</span><br><span class="line">                        page = list_entry(pages-&gt;prev, <span class="keyword">struct</span> page, lru);</span><br><span class="line">                        list_del(&amp;page-&gt;lru);</span><br><span class="line">                        <span class="keyword">if</span> (add_to_page_cache_lru(page, mapping,</span><br><span class="line">                                                  page-&gt;index, GFP_KERNEL))</span><br><span class="line">                                <span class="keyword">goto</span> next_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * map.m_lblk是上一个block_in_file</span></span><br><span class="line"><span class="comment">                 * map.m_lblk + map.m_len是需要读取长度的最后一个blokaddr</span></span><br><span class="line"><span class="comment">                 * 因此这里的意思是，如果是在这个 map.m_lblk &lt; block_in_file &lt; map.m_lblk + map.m_len </span></span><br><span class="line"><span class="comment">                 * 这个范围里面，不需要map，直接将上次的blkaddr+1就是需要的地址</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 循环第二步，如果上一次找到了page，则跳到 got_it 通过bio获取page的具体数据</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED) &amp;&amp; block_in_file &gt; <span class="built_in">map</span>.m_lblk &amp;&amp;</span><br><span class="line">                        block_in_file &lt; (<span class="built_in">map</span>.m_lblk + <span class="built_in">map</span>.m_len))</span><br><span class="line">                        <span class="keyword">goto</span> got_it;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 循环第三步，使用page offset和length，通过f2fs_map_blocks获得物理地址</span></span><br><span class="line">                <span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (block_in_file &lt; last_block) &#123;</span><br><span class="line">                        <span class="built_in">map</span>.m_lblk = block_in_file; <span class="comment">// 文件的第几个block</span></span><br><span class="line">                        <span class="built_in">map</span>.m_len = last_block - block_in_file; <span class="comment">// 读取的block的长度</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">0</span>,</span><br><span class="line">                                                F2FS_GET_BLOCK_READ))</span><br><span class="line">                                <span class="keyword">goto</span> set_error_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">got_it:</span><br><span class="line">                <span class="comment">// 循环第四步，通过map的结果执行不一样的处理方式</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED)) &#123; <span class="comment">// 如果找到了地址，则计算block_nr得到磁盘的地址</span></span><br><span class="line">                        block_nr = <span class="built_in">map</span>.m_pblk + block_in_file - <span class="built_in">map</span>.m_lblk;</span><br><span class="line">                        SetPageMappedToDisk(page);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!PageUptodate(page) &amp;&amp; !cleancache_get_page(page)) &#123;</span><br><span class="line">                                SetPageUptodate(page);</span><br><span class="line">                                <span class="keyword">goto</span> confused;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取失败了，则跳过这个page</span></span><br><span class="line">                        zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                        SetPageUptodate(page);</span><br><span class="line">                        unlock_page(page);</span><br><span class="line">                        <span class="keyword">goto</span> next_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这部分开始用于将物理地址通过submit_bio提交到磁盘读取数据</span></span><br><span class="line"><span class="comment">                 * 由于从磁盘读取数据是一个相对耗时的操作，</span></span><br><span class="line"><span class="comment">                 * 因此显然每读取一个页就访问一次磁盘一次的方式是低效的且影响读性能的，</span></span><br><span class="line"><span class="comment">                 * 所以F2FS会尽量一次性提交多个页到磁盘读取数据，以提高性能。</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 这部分开始就是具体实现:</span></span><br><span class="line"><span class="comment">                 * 1. 创建一个bio(最大一次性提交256个页)</span></span><br><span class="line"><span class="comment">                 * 2. 将需要读取的页添加到这个bio中，</span></span><br><span class="line"><span class="comment">                 *     ------如果bio未满则将page添加到bio中</span></span><br><span class="line"><span class="comment">                 *     ------如果bio满了立即访问磁盘读取</span></span><br><span class="line"><span class="comment">                 *     ------如果循环结束以后，bio还是未满，则通过本函数末尾的操作提交未满的bio。</span></span><br><span class="line"><span class="comment">                 *     </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第五步，判断bio装的page是否到了设定的最大数量，如果到了最大值则先发送到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (bio &amp;&amp; (last_block_in_bio != block_nr - <span class="number">1</span>)) &#123;</span><br><span class="line">submit_and_realloc:</span><br><span class="line">                        submit_bio(READ, bio);</span><br><span class="line">                        bio = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第六步，如果bio是空，则创建一个bio，然后指定的f2fs_read_end_io进行读取</span></span><br><span class="line">                <span class="keyword">if</span> (bio == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_ctx</span> *<span class="title">ctx</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (f2fs_encrypted_inode(inode) &amp;&amp;</span><br><span class="line">                                        S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"></span><br><span class="line">                                ctx = fscrypt_get_ctx(inode, GFP_NOFS);</span><br><span class="line">                                <span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">                                        <span class="keyword">goto</span> set_error_page;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">/* wait the page to be moved by cleaning */</span></span><br><span class="line">                                f2fs_wait_on_encrypted_page_writeback(</span><br><span class="line">                                                F2FS_I_SB(inode), block_nr);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bio = bio_alloc(GFP_KERNEL,</span><br><span class="line">                                <span class="type">min_t</span>(<span class="type">int</span>, nr_pages, BIO_MAX_PAGES)); <span class="comment">// 创建bio</span></span><br><span class="line">                        <span class="keyword">if</span> (!bio) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (ctx)</span><br><span class="line">                                        fscrypt_release_ctx(ctx);</span><br><span class="line">                                <span class="keyword">goto</span> set_error_page;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bio-&gt;bi_bdev = bdev;</span><br><span class="line">                        bio-&gt;bi_iter.bi_sector = SECTOR_FROM_BLOCK(block_nr); <span class="comment">// 设定bio的sector地址</span></span><br><span class="line">                        bio-&gt;bi_end_io = f2fs_read_end_io;</span><br><span class="line">                        bio-&gt;bi_private = ctx;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第七步，将page加入到bio中，等待第五步满了之后发送到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (bio_add_page(bio, page, blocksize, <span class="number">0</span>) &lt; blocksize)</span><br><span class="line">                        <span class="keyword">goto</span> submit_and_realloc;</span><br><span class="line"></span><br><span class="line">set_error_page:</span><br><span class="line">                SetPageError(page);</span><br><span class="line">                zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                unlock_page(page);</span><br><span class="line">                <span class="keyword">goto</span> next_page;</span><br><span class="line">confused: <span class="comment">// 特殊情况进行submit bio</span></span><br><span class="line">                <span class="keyword">if</span> (bio) &#123;</span><br><span class="line">                        submit_bio(READ, bio);</span><br><span class="line">                        bio = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unlock_page(page);</span><br><span class="line">next_page:</span><br><span class="line">                <span class="keyword">if</span> (pages)</span><br><span class="line">                        put_page(page);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        BUG_ON(pages &amp;&amp; !list_empty(pages));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还有bio没有处理，例如读取的页遍历完以后，还没有达到第五步要求的bio的最大保存页数，就会在这里提交bio到磁盘读取</span></span><br><span class="line">        <span class="keyword">if</span> (bio)</span><br><span class="line">                submit_bio(READ, bio);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="garbage-collection">garbage collection</h3>
<p>F2FS 的 GC 入口在 <code>f2fs_gc()</code>。这个函数的 caller 有 2 个：</p>
<ul>
<li>一个是前面接触到的 <code>f2fs_balance_fs()</code></li>
<li>另一个是后台 <code>kthread</code> 执行的 <code>gc_thread_func()</code></li>
</ul>
<h4 id="Background-GC">Background GC</h4>
<p>f2fs_fill_super() 初始化执行了 start_gc_thread()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start_gc_thread</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 一个 kthread 封装类</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_gc_kthread</span> *<span class="title">gc_th</span>;</span></span><br><span class="line"></span><br><span class="line">        gc_th = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_gc_kthread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!gc_th)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        sbi-&gt;gc_thread = gc_th;</span><br><span class="line">        init_waitqueue_head(&amp;sbi-&gt;gc_thread-&gt;gc_wait_queue_head);</span><br><span class="line">        <span class="comment">// kthread 的任务是 gc_thread_func</span></span><br><span class="line">        sbi-&gt;gc_thread-&gt;f2fs_gc_task = kthread_run(gc_thread_func, sbi,</span><br><span class="line">                                GC_THREAD_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(gc_th-&gt;f2fs_gc_task)) &#123;</span><br><span class="line">                kfree(gc_th);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_thread_func</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> data;</span><br><span class="line">        <span class="type">wait_queue_head_t</span> *wq = &amp;sbi-&gt;gc_thread-&gt;gc_wait_queue_head;</span><br><span class="line">        <span class="type">long</span> wait_ms;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC_THREAD_MIN_SLEEP_TIME: 10s</span></span><br><span class="line">        wait_ms = GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// freezer 特性，如果系统处于休眠则等待</span></span><br><span class="line">                <span class="keyword">if</span> (try_to_freeze())</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 等待 wait_ms 时间，这个数值会在后续动态调节</span></span><br><span class="line">                        wait_event_interruptible_timeout(*wq,</span><br><span class="line">                                                kthread_should_stop(),</span><br><span class="line">                                                msecs_to_jiffies(wait_ms));</span><br><span class="line">                <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有足够 free section，会强制进入主流程 f2fs_gc()</span></span><br><span class="line">                <span class="comment">// 否则什么都不干</span></span><br><span class="line">                f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!test_opt(sbi, BG_GC))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * [GC triggering condition]</span></span><br><span class="line"><span class="comment">                 * 0. GC is not conducted currently.</span></span><br><span class="line"><span class="comment">                 * 1. There are enough dirty segments.</span></span><br><span class="line"><span class="comment">                 * 2. IO subsystem is idle by checking the # of writeback pages.</span></span><br><span class="line"><span class="comment">                 * 3. IO subsystem is idle by checking the # of requests in</span></span><br><span class="line"><span class="comment">                 *    bdev&#x27;s request list.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Note) We have to avoid triggering GCs too much frequently.</span></span><br><span class="line"><span class="comment">                 * Because it is possible that some segments can be</span></span><br><span class="line"><span class="comment">                 * invalidated soon after by user update or deletion.</span></span><br><span class="line"><span class="comment">                 * So, I&#x27;d like to wait some time to collect dirty segments.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!mutex_trylock(&amp;sbi-&gt;gc_mutex))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!is_idle(sbi)) &#123;</span><br><span class="line">                        wait_ms = increase_sleep_time(wait_ms);</span><br><span class="line">                        mutex_unlock(&amp;sbi-&gt;gc_mutex);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// invalid（没写过的 block）超 40%，就会缩减等待时间，提高后台频率</span></span><br><span class="line">                <span class="keyword">if</span> (has_enough_invalid_blocks(sbi))</span><br><span class="line">                        <span class="comment">// 减 10s，但不超过 10s 阈值</span></span><br><span class="line">                        wait_ms = decrease_sleep_time(wait_ms);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 加 10s，但不超过 30s 阈值</span></span><br><span class="line">                        wait_ms = increase_sleep_time(wait_ms);</span><br><span class="line"></span><br><span class="line">                sbi-&gt;bg_gc++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入 GC 主流程</span></span><br><span class="line">                <span class="keyword">if</span> (f2fs_gc(sbi) == GC_NONE)</span><br><span class="line">                        <span class="comment">// 作者的意思应该是没有发生 GC，可能的情况是：</span></span><br><span class="line">                        <span class="comment">// - super block 尚未完成初始化</span></span><br><span class="line">                        <span class="comment">// - victim 挑选失败（比如每一个 segno 都成本过高）</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// GC_THREAD_NOGC_SLEEP_TIME: 10s</span></span><br><span class="line">                        wait_ms = GC_THREAD_NOGC_SLEEP_TIME;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (wait_ms == GC_THREAD_NOGC_SLEEP_TIME)</span><br><span class="line">                        <span class="comment">// 如果上一次走了 NOGC 的情况，这次强制降低频率</span></span><br><span class="line">                        <span class="comment">// GC_THREAD_MAX_SLEEP_TIME: 30s</span></span><br><span class="line">                        wait_ms = GC_THREAD_MAX_SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (!kthread_should_stop());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">has_enough_invalid_blocks</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 没有写过的 block 数目</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// LFS 写操作下，旧 block 不算入 written</span></span><br><span class="line">        <span class="comment">// 详见 update_sit_entry() 的 written_valid_blocks 更新</span></span><br><span class="line">        <span class="type">block_t</span> invalid_user_blocks = sbi-&gt;user_block_count -</span><br><span class="line">                                        written_block_count(sbi);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Background GC is triggered with the following condition.</span></span><br><span class="line"><span class="comment">         * 1. There are a number of invalid blocks.</span></span><br><span class="line"><span class="comment">         * 2. There is not enough free space.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// invalid user 超过了 40% 总数，free user 小于 40% 总数</span></span><br><span class="line">        <span class="keyword">if</span> (invalid_user_blocks &gt; limit_invalid_user_blocks(sbi) &amp;&amp;</span><br><span class="line">                        free_user_blocks(sbi) &lt; limit_free_user_blocks(sbi))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="title function_">decrease_sleep_time</span><span class="params">(<span class="type">long</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 减去 10s，但不得低于 10s</span></span><br><span class="line">        wait -= GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">if</span> (wait &lt;= GC_THREAD_MIN_SLEEP_TIME)</span><br><span class="line">                wait = GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">return</span> wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="title function_">increase_sleep_time</span><span class="params">(<span class="type">long</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 加上 10s，但不得高于 30s</span></span><br><span class="line">        wait += GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">if</span> (wait &gt; GC_THREAD_MAX_SLEEP_TIME)</span><br><span class="line">                wait = GC_THREAD_MAX_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">return</span> wait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主流程">主流程</h4>
<p>不管前台 GC 还是后台 GC，都会进入到统一的 GC 接口 f2fs_gc()。后台 GC 的情况在前面已经说明了；而前台 GC 可能会通过 f2fs_balance_fs() 在多个流程插入，只要 free section 低于预期，就会进入主流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_gc</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ilist</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno, i;</span><br><span class="line">        <span class="type">int</span> gc_type = BG_GC;</span><br><span class="line">        <span class="type">int</span> gc_status = GC_NONE;</span><br><span class="line"></span><br><span class="line">        INIT_LIST_HEAD(&amp;ilist);</span><br><span class="line">gc_more:</span><br><span class="line">        <span class="comment">// 不清楚 MS_ACTIVE 具体含义</span></span><br><span class="line">        <span class="comment">// 但是在 mount 过程中 VFS 会加上这个标记</span></span><br><span class="line">        <span class="keyword">if</span> (!(sbi-&gt;sb-&gt;s_flags &amp; MS_ACTIVE))</span><br><span class="line">                <span class="keyword">goto</span> stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有足够的 free section</span></span><br><span class="line">        <span class="comment">// 那就改为 FG GC，默认是 BG GC</span></span><br><span class="line">        <span class="keyword">if</span> (has_not_enough_free_secs(sbi))</span><br><span class="line">                gc_type = FG_GC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// victim selection 过程，完成结果传入 segno</span></span><br><span class="line">        <span class="keyword">if</span> (!__get_victim(sbi, &amp;segno, gc_type, NO_CHECK_TYPE))</span><br><span class="line">                <span class="keyword">goto</span> stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 论文提到，GC 执行是以 section 为单位的</span></span><br><span class="line">        <span class="comment">// 以拿到的 segment 为起始遍历 section 长度</span></span><br><span class="line">        <span class="comment">// 一般就一次，因为 1 segment = 1 section</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sbi-&gt;segs_per_sec; i++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * do_garbage_collect will give us three gc_status:</span></span><br><span class="line"><span class="comment">                 * GC_ERROR, GC_DONE, and GC_BLOCKED.</span></span><br><span class="line"><span class="comment">                 * If GC is finished uncleanly, we have to return</span></span><br><span class="line"><span class="comment">                 * the victim to dirty segment list.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 核心函数</span></span><br><span class="line">                gc_status = do_garbage_collect(sbi, segno + i, &amp;ilist, gc_type);</span><br><span class="line">                <span class="keyword">if</span> (gc_status != GC_DONE)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (has_not_enough_free_secs(sbi)) &#123;</span><br><span class="line">                write_checkpoint(sbi, (gc_status == GC_BLOCKED), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (has_not_enough_free_secs(sbi))</span><br><span class="line">                        <span class="keyword">goto</span> gc_more;</span><br><span class="line">        &#125;</span><br><span class="line">stop:</span><br><span class="line">        mutex_unlock(&amp;sbi-&gt;gc_mutex);</span><br><span class="line"></span><br><span class="line">        put_gc_inode(&amp;ilist);</span><br><span class="line">        <span class="keyword">return</span> gc_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 GC 真正执行前，需要挑选 victim</p>
<h4 id="Victim-selection">Victim selection</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过注册接口的方式，可以自己实现垃圾回收的选择算法</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __get_victim(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> *victim,</span><br><span class="line">                                                <span class="type">int</span> gc_type, <span class="type">int</span> type)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        mutex_lock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        ret = DIRTY_I(sbi)-&gt;v_ops-&gt;get_victim(sbi, victim, gc_type, type, LFS);</span><br><span class="line">        mutex_unlock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* victim selection function for cleaning and SSR */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">victim_selection</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*get_victim)(<span class="keyword">struct</span> f2fs_sb_info *, <span class="type">unsigned</span> <span class="type">int</span> *,</span><br><span class="line">                                                        <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">victim_selection</span> <span class="title">default_v_ops</span> =</span> &#123;</span><br><span class="line">        .get_victim = get_victim_by_default,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called from two pathes.</span></span><br><span class="line"><span class="comment"> * One is garbage collection and the other is SSR segment selection.</span></span><br><span class="line"><span class="comment"> * When it is called during GC, it just gets a victim segment</span></span><br><span class="line"><span class="comment"> * and it does not remove it from dirty seglist.</span></span><br><span class="line"><span class="comment"> * When it is called from SSR segment selection, it finds a segment</span></span><br><span class="line"><span class="comment"> * which has minimum valid blocks and removes it from dirty seglist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_victim_by_default</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">int</span> *result, <span class="type">int</span> gc_type, <span class="type">int</span> type, <span class="type">char</span> alloc_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">victim_sel_policy</span> <span class="title">p</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno;</span><br><span class="line">        <span class="type">int</span> nsearched = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果空间不足，这里固定为 LFS</span></span><br><span class="line">        p.alloc_mode = alloc_mode;</span><br><span class="line">        <span class="comment">// 如果空间不足，这里确定：</span></span><br><span class="line">        <span class="comment">// - gc_mode 为 greedy</span></span><br><span class="line">        <span class="comment">// - ofs_unit 为 1</span></span><br><span class="line">        select_policy(sbi, gc_type, type, &amp;p);</span><br><span class="line"></span><br><span class="line">        p.min_segno = NULL_SEGNO;</span><br><span class="line">        p.min_cost = get_max_cost(sbi, &amp;p);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.alloc_mode == LFS &amp;&amp; gc_type == FG_GC) &#123;</span><br><span class="line">                <span class="comment">// 先尝试获取 BG_GC 获得的 victim</span></span><br><span class="line">                <span class="comment">// min_segno 应该是 min_cost 对应的 segment</span></span><br><span class="line">                <span class="comment">// 毕竟 BG 的算法是 min_cost 的</span></span><br><span class="line">                p.min_segno = check_bg_victims(sbi);</span><br><span class="line">                <span class="keyword">if</span> (p.min_segno != NULL_SEGNO)</span><br><span class="line">                        <span class="comment">// 如果有就立刻结束</span></span><br><span class="line">                        <span class="keyword">goto</span> got_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则再按照算法查找</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> cost;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// p.offset 指的是 last scanned bitmap offset，因此从这里开始</span></span><br><span class="line">                <span class="comment">// 从 dirty segmap 选择一个 dirty segment</span></span><br><span class="line">                segno = find_next_bit(p.dirty_segmap,</span><br><span class="line">                                                TOTAL_SEGS(sbi), p.offset);</span><br><span class="line">                <span class="comment">// 没找到 dirty segment</span></span><br><span class="line">                <span class="comment">// 循环会跳出</span></span><br><span class="line">                <span class="keyword">if</span> (segno &gt;= TOTAL_SEGS(sbi)) &#123;</span><br><span class="line">                        <span class="comment">// last_victim：一个大小为 2 的数组，按照 gc_mode 区分</span></span><br><span class="line">                        <span class="comment">// 此时先清空？不太明白，感觉是指完整扫描过一遍了</span></span><br><span class="line">                        <span class="keyword">if</span> (sbi-&gt;last_victim[p.gc_mode]) &#123;</span><br><span class="line">                                sbi-&gt;last_victim[p.gc_mode] = <span class="number">0</span>;</span><br><span class="line">                                p.offset = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个 find_next_bit 的开始地址</span></span><br><span class="line">                p.offset = ((segno / p.ofs_unit) * p.ofs_unit) + p.ofs_unit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> victim_segmap 默认为空，见 init_victim_segmap()</span></span><br><span class="line">                <span class="comment">// 但是挑选的 dirty segment 这里已经被 victim segmap 标记</span></span><br><span class="line">                <span class="comment">// 更新时机见 got_it 部分</span></span><br><span class="line">                <span class="keyword">if</span> (test_bit(segno, dirty_i-&gt;victim_segmap[FG_GC]))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (gc_type == BG_GC &amp;&amp;</span><br><span class="line">                                test_bit(segno, dirty_i-&gt;victim_segmap[BG_GC]))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 不处理 curseg 指向的起始 section</span></span><br><span class="line">                <span class="keyword">if</span> (IS_CURSEC(sbi, GET_SECNO(sbi, segno)))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 见下方具体流程</span></span><br><span class="line">                <span class="comment">// 在当前的上下文中，就是获取 valid block 数目作为成本</span></span><br><span class="line">                cost = get_gc_cost(sbi, segno, &amp;p);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果找到真·min_cost，那就更新对应的 min_segno</span></span><br><span class="line">                <span class="keyword">if</span> (p.min_cost &gt; cost) &#123;</span><br><span class="line">                        p.min_segno = segno;</span><br><span class="line">                        p.min_cost = cost;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成本太大，不能选</span></span><br><span class="line">                <span class="comment">// 需要下一次循环用新的 p.offset 再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (cost == get_max_cost(sbi, &amp;p))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 迭代是有限次数的，MAX_VICTIM_SEARCH = 20</span></span><br><span class="line">                <span class="keyword">if</span> (nsearched++ &gt;= MAX_VICTIM_SEARCH) &#123;</span><br><span class="line">                        <span class="comment">// 最后一次找到的 segno，不管是否 min 都记下了</span></span><br><span class="line">                        <span class="comment">// 这有什么用呢？我认为是加速 GC，因为在 select_policy 中，</span></span><br><span class="line">                        <span class="comment">// 可以看到 GC 扫描开始的 p.offset 就是使用 last_victim</span></span><br><span class="line">                        sbi-&gt;last_victim[p.gc_mode] = segno;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">got_it:</span><br><span class="line">        <span class="keyword">if</span> (p.min_segno != NULL_SEGNO) &#123;</span><br><span class="line">                <span class="comment">// 从这里可以看出最终目标就是求出 p.min_segno</span></span><br><span class="line">                <span class="comment">// 这里一直有除后再乘上的操作是因为作者假定 section 和 segment 不是统一单位</span></span><br><span class="line">                *result = (p.min_segno / p.ofs_unit) * p.ofs_unit;</span><br><span class="line">                <span class="keyword">if</span> (p.alloc_mode == LFS) &#123;</span><br><span class="line">                        <span class="type">int</span> i;</span><br><span class="line">                        <span class="comment">// 标记对应的 victim segmap</span></span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p.ofs_unit; i++)</span><br><span class="line">                                set_bit(*result + i,</span><br><span class="line">                                        dirty_i-&gt;victim_segmap[gc_type]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (p.min_segno == NULL_SEGNO) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">select_policy</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">int</span> gc_type,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> type, <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LFS 走这里</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;alloc_mode) &#123;</span><br><span class="line">                <span class="comment">// 在当前的流程中，p 已经确定是 LFS，因此是 GREEDY</span></span><br><span class="line">                p-&gt;gc_mode = GC_GREEDY;</span><br><span class="line">                p-&gt;dirty_segmap = dirty_i-&gt;dirty_segmap[type];</span><br><span class="line">                p-&gt;ofs_unit = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 赋予gc算法类型，默认有两种算法，即greedy算法(GC_GREEDY)，以及cost-benefit算法(GC_CB)</span></span><br><span class="line">                p-&gt;gc_mode = select_gc_type(gc_type);</span><br><span class="line">                <span class="comment">// 即脏的segment所对应的segmap，它的作用是标记了这个segmen里面的block有效无效信息</span></span><br><span class="line">                p-&gt;dirty_segmap = dirty_i-&gt;dirty_segmap[DIRTY];</span><br><span class="line">                p-&gt;ofs_unit = sbi-&gt;segs_per_sec;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;offset = sbi-&gt;last_victim[p-&gt;gc_mode]; <span class="comment">// 上一个被回收的segment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_max_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;gc_mode == GC_GREEDY)</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocks_per_seg) * p-&gt;ofs_unit;</span><br><span class="line">        <span class="comment">// CB 是 Cost-Benefit 的意思</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;gc_mode == GC_CB)</span><br><span class="line">                <span class="keyword">return</span> UINT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* No other gc_mode */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">check_bg_victims</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the gc_type is FG_GC, we can select victim segments</span></span><br><span class="line"><span class="comment">         * selected by background GC before.</span></span><br><span class="line"><span class="comment">         * Those segments guarantee they have small valid blocks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        segno = find_next_bit(dirty_i-&gt;victim_segmap[BG_GC],</span><br><span class="line">                                                TOTAL_SEGS(sbi), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (segno &lt; TOTAL_SEGS(sbi)) &#123;</span><br><span class="line">                clear_bit(segno, dirty_i-&gt;victim_segmap[BG_GC]);</span><br><span class="line">                <span class="keyword">return</span> segno;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NULL_SEGNO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_gc_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno,</span></span><br><span class="line"><span class="params">                                        <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;alloc_mode == SSR)</span><br><span class="line">                <span class="keyword">return</span> get_seg_entry(sbi, segno)-&gt;ckpt_valid_blocks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* alloc_mode == LFS */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;gc_mode == GC_GREEDY)</span><br><span class="line">                <span class="comment">// 从 select_policy() 分析得出目前流程会走到这里</span></span><br><span class="line">                <span class="comment">// 查找 valid block 数目最少的 segno，避免迁移成本</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> 这里不用取最小，这个工作在 get_victim_by_default() 完成</span></span><br><span class="line">                <span class="comment">// 实现上就是得到 sentry 的 valid_blocks 字段（非常直接）</span></span><br><span class="line">                <span class="keyword">return</span> get_valid_blocks(sbi, segno, sbi-&gt;segs_per_sec);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 最优成本算法，考虑老化</span></span><br><span class="line">                <span class="keyword">return</span> get_cb_cost(sbi, segno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_cb_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> secno = GET_SECNO(sbi, segno);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> start = secno * sbi-&gt;segs_per_sec;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mtime = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vblocks;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> u;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累计 mtime</span></span><br><span class="line">        <span class="comment">// 这里 mtime 是每个 segment 加起来的</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sbi-&gt;segs_per_sec; i++)</span><br><span class="line">                mtime += get_seg_entry(sbi, start + i)-&gt;mtime;</span><br><span class="line">        vblocks = get_valid_blocks(sbi, segno, sbi-&gt;segs_per_sec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换算 mtime 为 segment 平均水平</span></span><br><span class="line">        mtime = div_u64(mtime, sbi-&gt;segs_per_sec);</span><br><span class="line">        vblocks = div_u64(vblocks, sbi-&gt;segs_per_sec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数 1：u，块利用率（util%）的意思</span></span><br><span class="line">        <span class="comment">// u = vblock * 100 / 512</span></span><br><span class="line">        <span class="comment">//   = vblock / 512 * 100 (vblock &lt;= 512)</span></span><br><span class="line">        <span class="comment">//   &lt;= 100</span></span><br><span class="line">        u = (vblocks * <span class="number">100</span>) &gt;&gt; sbi-&gt;log_blocks_per_seg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle if the system time is changed by user */</span></span><br><span class="line">        <span class="comment">// min 和 max 指的是这个 segment 中的最大最小修改时间</span></span><br><span class="line">        <span class="comment">// 话说为啥平均水平会超出最值呢？好神奇哦</span></span><br><span class="line">        <span class="keyword">if</span> (mtime &lt; sit_i-&gt;min_mtime)</span><br><span class="line">                sit_i-&gt;min_mtime = mtime;</span><br><span class="line">        <span class="keyword">if</span> (mtime &gt; sit_i-&gt;max_mtime)</span><br><span class="line">                sit_i-&gt;max_mtime = mtime;</span><br><span class="line">        <span class="comment">// 避免除以 0</span></span><br><span class="line">        <span class="keyword">if</span> (sit_i-&gt;max_mtime != sit_i-&gt;min_mtime)</span><br><span class="line">                <span class="comment">// 参数 2：age，一个 segment 的年纪</span></span><br><span class="line">                <span class="comment">// age = 100 - 100*(avg - min)/(max - min)</span></span><br><span class="line">                <span class="comment">// 这个估值方式有点疑问，为什么是单调时钟而不考虑 sbi 设墙上时钟？</span></span><br><span class="line">                <span class="comment">// 总之是这个算法吧，很久没任何改动就大概是年纪大（avg≈min，age≈100）</span></span><br><span class="line">                age = <span class="number">100</span> - div64_u64(<span class="number">100</span> * (mtime - sit_i-&gt;min_mtime),</span><br><span class="line">                                sit_i-&gt;max_mtime - sit_i-&gt;min_mtime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用率部分为 (100-u)/(100+u)，u 范围 [0,100] 的结果是单调递减的</span></span><br><span class="line">        <span class="comment">// 考虑负数的优先级反转后（且要尽可能小的数值），总结：</span></span><br><span class="line">        <span class="comment">// - 年纪越大，越容易毕业</span></span><br><span class="line">        <span class="comment">// - 利用率越低，越容易毕业</span></span><br><span class="line">        <span class="keyword">return</span> UINT_MAX - ((<span class="number">100</span> * (<span class="number">100</span> - u) * age) / (<span class="number">100</span> + u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GC-procedure">GC procedure</h4>
<p>处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mi>s</mi><mi>e</mi><mi>g</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mtext>  </mtext><mi>s</mi><mi>e</mi><mi>g</mi><mi>n</mi><mi>o</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left[segno,\; segno+segments\_per\_section\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">sec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>编号范围的 segment</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_garbage_collect</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> list_head *ilist, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">sum_page</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> *<span class="title">sum</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = GC_DONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read segment summary of victim */</span></span><br><span class="line">        <span class="comment">// 获取关联的 summary</span></span><br><span class="line">        sum_page = get_sum_page(sbi, segno);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(sum_page))</span><br><span class="line">                <span class="keyword">return</span> GC_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CP needs to lock sum_page. In this time, we don&#x27;t need</span></span><br><span class="line"><span class="comment">         * to lock this page, because this summary page is not gone anywhere.</span></span><br><span class="line"><span class="comment">         * Also, this page is not gonna be updated before GC is done.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unlock_page(sum_page);</span><br><span class="line">        sum = page_address(sum_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区分类型的 GC 操作</span></span><br><span class="line">        <span class="keyword">switch</span> (GET_SUM_TYPE((&amp;sum-&gt;footer))) &#123;</span><br><span class="line">        <span class="keyword">case</span> SUM_TYPE_NODE:</span><br><span class="line">                ret = gc_node_segment(sbi, sum-&gt;entries, segno, gc_type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUM_TYPE_DATA:</span><br><span class="line">                ret = gc_data_segment(sbi, sum-&gt;entries, ilist, segno, gc_type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stat_inc_seg_count(sbi, GET_SUM_TYPE((&amp;sum-&gt;footer)));</span><br><span class="line">        stat_inc_call_count(sbi-&gt;stat_info);</span><br><span class="line"></span><br><span class="line">        f2fs_put_page(sum_page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function tries to get parent node of victim data block, and identifies</span></span><br><span class="line"><span class="comment"> * data block validity. If the block is valid, copy that with cold status and</span></span><br><span class="line"><span class="comment"> * modify parent node.</span></span><br><span class="line"><span class="comment"> * If the parent node is not valid or the data block address is different,</span></span><br><span class="line"><span class="comment"> * the victim data block is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_data_segment</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> f2fs_summary *sum,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *ilist, <span class="type">unsigned</span> <span class="type">int</span> segno, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> sbi-&gt;sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> *<span class="title">entry</span>;</span></span><br><span class="line">        <span class="type">block_t</span> start_addr;</span><br><span class="line">        <span class="type">int</span> err, off;</span><br><span class="line">        <span class="type">int</span> phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// segno 起始 block 转为 block_t 单位</span></span><br><span class="line">        start_addr = START_BLOCK(sbi, segno);</span><br><span class="line"></span><br><span class="line">next_step:</span><br><span class="line">        entry = sum;</span><br><span class="line">        <span class="comment">// 遍历 segment，off 是 block 个数偏移量</span></span><br><span class="line">        <span class="comment">// 完整 for 一遍后才会 phase 递增，再执行 for</span></span><br><span class="line">        <span class="keyword">for</span> (off = <span class="number">0</span>; off &lt; sbi-&gt;blocks_per_seg; off++, entry++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">data_page</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">node_info</span> <span class="title">dni</span>;</span> <span class="comment">/* dnode info for the data */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node, nofs;</span><br><span class="line">                <span class="type">block_t</span> start_bidx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * It makes sure that free segments are able to write</span></span><br><span class="line"><span class="comment">                 * all the dirty node pages before CP after this CP.</span></span><br><span class="line"><span class="comment">                 * So let&#x27;s check the space of dirty node pages.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (should_do_checkpoint(sbi)) &#123;</span><br><span class="line">                        mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">                        block_operations(sbi);</span><br><span class="line">                        err = GC_BLOCKED;</span><br><span class="line">                        <span class="keyword">goto</span> stop;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 segno 获取 sentry</span></span><br><span class="line">                <span class="comment">// 再根据 off 进行 sentry-&gt;cur_valid_map 的 testbit</span></span><br><span class="line">                <span class="comment">// 正常返回 GC_OK (bit:1)</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">                <span class="comment">// bitmap 更新时机在前面 SIT update 章节中的 update_sit_entry()</span></span><br><span class="line">                <span class="comment">// 就是说 write page 时一般都置旧页/块为 1</span></span><br><span class="line">                err = check_valid_map(sbi, segno, off);</span><br><span class="line">                <span class="keyword">if</span> (err == GC_NEXT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 阶段 0，预读 node page</span></span><br><span class="line">                        <span class="comment">//（nid 通过 block 寻址获得，赋值 callee 见 set_summary()）</span></span><br><span class="line">                        <span class="comment">// <span class="doctag">NOTE:</span> 这些预读是为下一个 phase 确保 page 已在内存中</span></span><br><span class="line">                        ra_node_page(sbi, le32_to_cpu(entry-&gt;nid));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Get an inode by ino with checking validity */</span></span><br><span class="line">                <span class="comment">// 获取 dni，可进一步获取 inode</span></span><br><span class="line">                err = check_dnode(sbi, entry, &amp;dni, start_addr + off, &amp;nofs);</span><br><span class="line">                <span class="keyword">if</span> (err == GC_NEXT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 阶段 1，预读 inode page</span></span><br><span class="line">                        ra_node_page(sbi, dni.ino);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// start_bidx 含义：start block index indicating the given node offset</span></span><br><span class="line">                start_bidx = start_bidx_of_node(nofs);</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> fill_node_footer()</span></span><br><span class="line">                ofs_in_node = le16_to_cpu(entry-&gt;ofs_in_node);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获得 inode 实例</span></span><br><span class="line">                        inode = f2fs_iget_nowait(sb, dni.ino);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 以 start_bidx + ofs_in_node 为 page index 定位到 data page</span></span><br><span class="line">                        data_page = find_data_page(inode,</span><br><span class="line">                                        start_bidx + ofs_in_node);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(data_page))</span><br><span class="line">                                <span class="keyword">goto</span> next_iput;</span><br><span class="line"></span><br><span class="line">                        f2fs_put_page(data_page, <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// inode 加入到 gc list（ilist，是一个栈上的链表）</span></span><br><span class="line">                        add_gc_inode(inode, ilist);</span><br><span class="line">                <span class="comment">// 这里 phase == 3</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 遍历找到 ino</span></span><br><span class="line">                        inode = find_gc_inode(dni.ino, ilist);</span><br><span class="line">                        <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">                                data_page = get_lock_data_page(inode,</span><br><span class="line">                                                start_bidx + ofs_in_node);</span><br><span class="line">                                <span class="keyword">if</span> (IS_ERR(data_page))</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                move_data_page(inode, data_page, gc_type);</span><br><span class="line">                                stat_inc_data_blk_count(sbi, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">next_iput:</span><br><span class="line">                iput(inode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++phase &lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">goto</span> next_step;</span><br><span class="line">        err = GC_DONE;</span><br><span class="line">stop:</span><br><span class="line">        <span class="keyword">if</span> (gc_type == FG_GC)</span><br><span class="line">                f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_gc_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> list_head *ilist)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">        <span class="comment">// inode_entry 是个&lt;list_head*, inode*&gt;二元组</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode_entry</span> *<span class="title">new_ie</span>, *<span class="title">ie</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免重复加入</span></span><br><span class="line">        list_for_each(this, ilist) &#123;</span><br><span class="line">                ie = list_entry(this, <span class="keyword">struct</span> inode_entry, <span class="built_in">list</span>);</span><br><span class="line">                <span class="keyword">if</span> (ie-&gt;inode == inode) &#123;</span><br><span class="line">                        iput(inode);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">repeat:</span><br><span class="line">        new_ie = kmem_cache_alloc(winode_slab, GFP_NOFS);</span><br><span class="line">        <span class="keyword">if</span> (!new_ie) &#123;</span><br><span class="line">                cond_resched();</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        new_ie-&gt;inode = inode;</span><br><span class="line">        list_add_tail(&amp;new_ie-&gt;<span class="built_in">list</span>, ilist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">find_gc_inode</span><span class="params">(<span class="type">nid_t</span> ino, <span class="keyword">struct</span> list_head *ilist)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode_entry</span> *<span class="title">ie</span>;</span></span><br><span class="line"></span><br><span class="line">        list_for_each(this, ilist) &#123;</span><br><span class="line">                ie = list_entry(this, <span class="keyword">struct</span> inode_entry, <span class="built_in">list</span>);</span><br><span class="line">                <span class="keyword">if</span> (ie-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">                        <span class="keyword">return</span> ie-&gt;inode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">move_data_page</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> page *page, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;mapping != inode-&gt;i_mapping)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inode != page-&gt;mapping-&gt;host)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageWriteback(page))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BG 的时候没有实际移动，而是设为 COLD</span></span><br><span class="line">        <span class="keyword">if</span> (gc_type == BG_GC) &#123;</span><br><span class="line">                set_page_dirty(page);</span><br><span class="line">                set_cold_data(page);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">struct</span> f2fs_sb_info *sbi = F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">                mutex_lock_op(sbi, DATA_WRITE);</span><br><span class="line">                <span class="keyword">if</span> (clear_page_dirty_for_io(page) &amp;&amp;</span><br><span class="line">                        S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                        dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                        inode_dec_dirty_dents(inode);</span><br><span class="line">                &#125;</span><br><span class="line">                set_cold_data(page);</span><br><span class="line">                <span class="comment">// 写到新的位置，见 Write operation 章节</span></span><br><span class="line">                do_write_data_page(page);</span><br><span class="line">                mutex_unlock_op(sbi, DATA_WRITE);</span><br><span class="line">                clear_cold_data(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Recovery">Recovery</h3>
<p>触发 checkpoint 的主流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We guarantee that this checkpoint procedure should not fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_checkpoint</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">bool</span> blocked, <span class="type">bool</span> is_umount)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">                mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">                <span class="comment">// 内部会 mutex lock 若干的锁</span></span><br><span class="line">                block_operations(sbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DATA 和 NODE 均是 main area block</span></span><br><span class="line">        <span class="comment">// META 则是 main area 之外的区域</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 然而 META 多是内存数据结构，刷下去也未必是最新的</span></span><br><span class="line">        f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">        f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">        f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * update checkpoint pack index</span></span><br><span class="line"><span class="comment">         * Increase the version number so that</span></span><br><span class="line"><span class="comment">         * SIT entries and seg summaries are written at correct place</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取 check point 版本号并且递增</span></span><br><span class="line">        ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">        ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write cached NAT/SIT entries to NAT/SIT area */</span></span><br><span class="line">        flush_nat_entries(sbi);</span><br><span class="line">        flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">        reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlock all the fs_lock[] in do_checkpoint() */</span></span><br><span class="line">        do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">        unblock_operations(sbi);</span><br><span class="line">        mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_checkpoint</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">bool</span> is_umount)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">        <span class="type">nid_t</span> last_nid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">block_t</span> start_blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp_page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> data_sum_blocks, orphan_blocks;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> crc32 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">void</span> *kaddr;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Flush all the NAT/SIT pages */</span></span><br><span class="line">        <span class="keyword">while</span> (get_pages(sbi, F2FS_DIRTY_META))</span><br><span class="line">                sync_meta_pages(sbi, META, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出last_nid，后面写到check point的next_free_nid</span></span><br><span class="line">        next_free_nid(sbi, &amp;last_nid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * modify checkpoint</span></span><br><span class="line"><span class="comment">         * version number is already updated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// checkpoint_ver在NAT/SIT flush前已更新</span></span><br><span class="line">        ckpt-&gt;elapsed_time = cpu_to_le64(get_mtime(sbi));</span><br><span class="line">        ckpt-&gt;valid_block_count = cpu_to_le64(valid_user_blocks(sbi));</span><br><span class="line">        ckpt-&gt;free_segment_count = cpu_to_le32(free_segments(sbi));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                ckpt-&gt;cur_node_segno[i] =</span><br><span class="line">                        cpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));</span><br><span class="line">                ckpt-&gt;cur_node_blkoff[i] =</span><br><span class="line">                        cpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));</span><br><span class="line">                ckpt-&gt;alloc_type[i + CURSEG_HOT_NODE] =</span><br><span class="line">                                curseg_alloc_type(sbi, i + CURSEG_HOT_NODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                ckpt-&gt;cur_data_segno[i] =</span><br><span class="line">                        cpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));</span><br><span class="line">                ckpt-&gt;cur_data_blkoff[i] =</span><br><span class="line">                        cpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));</span><br><span class="line">                ckpt-&gt;alloc_type[i + CURSEG_HOT_DATA] =</span><br><span class="line">                                curseg_alloc_type(sbi, i + CURSEG_HOT_DATA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ckpt-&gt;valid_node_count = cpu_to_le32(valid_node_count(sbi));</span><br><span class="line">        ckpt-&gt;valid_inode_count = cpu_to_le32(valid_inode_count(sbi));</span><br><span class="line">        ckpt-&gt;next_free_nid = cpu_to_le32(last_nid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 cp  + n data seg summary + orphan inode blocks */</span></span><br><span class="line">        <span class="comment">// 这是summary在CP area占用的page/block个数</span></span><br><span class="line">        data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line">        <span class="comment">// compact mode影响write_data_summaries()写入和restore_curseg_summaries()恢复</span></span><br><span class="line">        <span class="comment">// 1-2个page内可以搞定，就设为compact</span></span><br><span class="line">        <span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">                set_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                clear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orphan inode用于处理unlink/truncate时的一致性</span></span><br><span class="line">        <span class="comment">// 基本思路：</span></span><br><span class="line">        <span class="comment">// 1. 当需要删除/截断一个inode时，先把inode记录到orphan外存</span></span><br><span class="line">        <span class="comment">// 2. 操作成功后再从orphan移除</span></span><br><span class="line">        <span class="comment">// 3. 加载check point时会重做一遍仍在orphan里的操作</span></span><br><span class="line">        <span class="comment">// 这样在1-2操作完成前宕机仍保持一致性</span></span><br><span class="line">        orphan_blocks = (sbi-&gt;n_orphans + F2FS_ORPHANS_PER_BLOCK - <span class="number">1</span>)</span><br><span class="line">                                        / F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">        ckpt-&gt;cp_pack_start_sum = cpu_to_le32(<span class="number">1</span> + orphan_blocks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_umount) &#123;</span><br><span class="line">                set_ckpt_flags(ckpt, CP_UMOUNT_FLAG);</span><br><span class="line">                ckpt-&gt;cp_pack_total_block_count = cpu_to_le32(<span class="number">2</span> +</span><br><span class="line">                        data_sum_blocks + orphan_blocks + NR_CURSEG_NODE_TYPE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);</span><br><span class="line">                ckpt-&gt;cp_pack_total_block_count = cpu_to_le32(<span class="number">2</span> +</span><br><span class="line">                        data_sum_blocks + orphan_blocks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;n_orphans)</span><br><span class="line">                set_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                clear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update SIT/NAT bitmap */</span></span><br><span class="line">        <span class="comment">// __bitmap_ptr指向ckpt中对应的bitmap</span></span><br><span class="line">        <span class="comment">// 这两个函数会把对应的sit_i-&gt;sit_bitmap和nm_i-&gt;nat_bitmap拷贝到ckpt</span></span><br><span class="line">        get_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));</span><br><span class="line">        get_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));</span><br><span class="line"></span><br><span class="line">        crc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt-&gt;checksum_offset));</span><br><span class="line">        *(__le32 *)((<span class="type">unsigned</span> <span class="type">char</span> *)ckpt +</span><br><span class="line">                                le32_to_cpu(ckpt-&gt;checksum_offset))</span><br><span class="line">                                = cpu_to_le32(crc32);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的开始地址是有讲究的</span></span><br><span class="line">        <span class="comment">// 前面讲过cp pack之间是交替存放的，间隔segment</span></span><br><span class="line">        start_blk = __start_cp_addr(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write out checkpoint buffer at block 0 */</span></span><br><span class="line">        cp_page = grab_meta_page(sbi, start_blk++);</span><br><span class="line">        kaddr = page_address(cp_page);</span><br><span class="line">        <span class="comment">// 使用一个block存放ckpt</span></span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, ckpt, (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocksize));</span><br><span class="line">        set_page_dirty(cp_page);</span><br><span class="line">        f2fs_put_page(cp_page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用orphan_blocks数目的block存放orphan</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;n_orphans) &#123;</span><br><span class="line">                write_orphan_inodes(sbi, start_blk);</span><br><span class="line">                start_blk += orphan_blocks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compact mode和normal mode的写入方式不一样</span></span><br><span class="line">        <span class="comment">// 使用data_sum_blocks数目的block存放data summary</span></span><br><span class="line">        write_data_summaries(sbi, start_blk);</span><br><span class="line">        start_blk += data_sum_blocks;</span><br><span class="line">        <span class="keyword">if</span> (is_umount) &#123;</span><br><span class="line">                <span class="comment">// umount的情况还写入node summary</span></span><br><span class="line">                write_node_summaries(sbi, start_blk);</span><br><span class="line">                <span class="comment">// 固定占坑3个block</span></span><br><span class="line">                start_blk += NR_CURSEG_NODE_TYPE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* writeout checkpoint block */</span></span><br><span class="line">        <span class="comment">// 再使用一个block存放ckpt，用于校验</span></span><br><span class="line">        cp_page = grab_meta_page(sbi, start_blk);</span><br><span class="line">        kaddr = page_address(cp_page);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, ckpt, (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocksize));</span><br><span class="line">        set_page_dirty(cp_page);</span><br><span class="line">        f2fs_put_page(cp_page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的就是善后处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* wait for previous submitted node/meta pages writeback */</span></span><br><span class="line">        <span class="keyword">while</span> (get_pages(sbi, F2FS_WRITEBACK))</span><br><span class="line">                congestion_wait(BLK_RW_ASYNC, HZ / <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        filemap_fdatawait_range(sbi-&gt;node_inode-&gt;i_mapping, <span class="number">0</span>, LONG_MAX);</span><br><span class="line">        filemap_fdatawait_range(sbi-&gt;meta_inode-&gt;i_mapping, <span class="number">0</span>, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update user_block_counts */</span></span><br><span class="line">        sbi-&gt;last_valid_block_count = sbi-&gt;total_valid_block_count;</span><br><span class="line">        sbi-&gt;alloc_valid_block_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here, we only have one bio having CP pack */</span></span><br><span class="line">        <span class="keyword">if</span> (is_set_ckpt_flags(ckpt, CP_ERROR_FLAG))</span><br><span class="line">                <span class="comment">// 出事了就进入只读模式</span></span><br><span class="line">                sbi-&gt;sb-&gt;s_flags |= MS_RDONLY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                sync_meta_pages(sbi, META_FLUSH, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        clear_prefree_segments(sbi);</span><br><span class="line">        F2FS_RESET_SB_DIRT(sbi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the number of current summary pages for writing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">npages_for_summary_flush</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> total_size_bytes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// summary entry 数目</span></span><br><span class="line">        <span class="type">int</span> valid_sum_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, sum_space;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算curseg的sum block</span></span><br><span class="line">        <span class="keyword">for</span> (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sbi-&gt;ckpt-&gt;alloc_type[i] == SSR)</span><br><span class="line">                        valid_sum_count += sbi-&gt;blocks_per_seg;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 直接加上curseg-&gt;next_blkoff</span></span><br><span class="line">                        <span class="comment">// 一个seg内next_blkoff前的sum entry均有效</span></span><br><span class="line">                        valid_sum_count += curseg_blkoff(sbi, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么需要+1？</span></span><br><span class="line">        total_size_bytes = valid_sum_count * (SUMMARY_SIZE + <span class="number">1</span>)</span><br><span class="line">                        + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nat_journal) + <span class="number">2</span></span><br><span class="line">                        + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sit_journal) + <span class="number">2</span>;</span><br><span class="line">        sum_space = PAGE_CACHE_SIZE - SUM_FOOTER_SIZE;</span><br><span class="line">        <span class="comment">// 1个page内可以搞定</span></span><br><span class="line">        <span class="keyword">if</span> (total_size_bytes &lt; sum_space)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2个page内可以搞定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (total_size_bytes &lt; <span class="number">2</span> * sum_space)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 看后面分析，normal mode在3个page内必能搞定</span></span><br><span class="line">        <span class="comment">// 就是三种data type curseg，每种各写一个page</span></span><br><span class="line">        <span class="comment">// （sum_blk直接拷过去）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">block_t</span> __start_cp_addr(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">block_t</span> start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)-&gt;cp_blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前面分析过 cp pack，交替使用，pack 之间间隔 segment 单位</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;cur_cp_pack == <span class="number">2</span>)</span><br><span class="line">                start_addr += sbi-&gt;blocks_per_seg;</span><br><span class="line">        <span class="keyword">return</span> start_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">block_t</span> start_blk)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 区分 compact mode 还是 normal mode</span></span><br><span class="line">        <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))</span><br><span class="line">                write_compacted_summaries(sbi, start_blk);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                write_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_compacted_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">block_t</span> blkaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *kaddr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> *<span class="title">summary</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">seg_i</span>;</span></span><br><span class="line">        <span class="type">int</span> written_size = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里一开始传入 blkaddr 位于 CP area</span></span><br><span class="line">        <span class="comment">// 可能是 ckpt 后面，也可能是 orphan 后面</span></span><br><span class="line">        page = grab_meta_page(sbi, blkaddr++);</span><br><span class="line">        kaddr = (<span class="type">unsigned</span> <span class="type">char</span> *)page_address(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 1: write nat cache */</span></span><br><span class="line">        <span class="comment">// 写入HOT_DATA存放的NAT jorunal</span></span><br><span class="line">        seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, &amp;seg_i-&gt;sum_blk-&gt;n_nats, SUM_JOURNAL_SIZE);</span><br><span class="line">        written_size += SUM_JOURNAL_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 2: write sit cache */</span></span><br><span class="line">        <span class="comment">// 写入COLD_DATA存放的SIT journal</span></span><br><span class="line">        seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr + written_size, &amp;seg_i-&gt;sum_blk-&gt;n_sits,</span><br><span class="line">                                                SUM_JOURNAL_SIZE);</span><br><span class="line">        written_size += SUM_JOURNAL_SIZE;</span><br><span class="line"></span><br><span class="line">        set_page_dirty(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: write summary entries */</span></span><br><span class="line">        <span class="comment">// 写入summary entry</span></span><br><span class="line">        <span class="keyword">for</span> (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> blkoff;</span><br><span class="line">                seg_i = CURSEG_I(sbi, i);</span><br><span class="line">                <span class="keyword">if</span> (sbi-&gt;ckpt-&gt;alloc_type[i] == SSR)</span><br><span class="line">                        blkoff = sbi-&gt;blocks_per_seg;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 定位到最后的valid summary entry前</span></span><br><span class="line">                        blkoff = curseg_blkoff(sbi, i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 依次遍历即可</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blkoff; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                                page = grab_meta_page(sbi, blkaddr++);</span><br><span class="line">                                kaddr = (<span class="type">unsigned</span> <span class="type">char</span> *)page_address(page);</span><br><span class="line">                                written_size = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        summary = (<span class="keyword">struct</span> f2fs_summary *)(kaddr + written_size);</span><br><span class="line">                        *summary = seg_i-&gt;sum_blk-&gt;entries[j];</span><br><span class="line">                        written_size += SUMMARY_SIZE;</span><br><span class="line">                        set_page_dirty(page);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// page还没满</span></span><br><span class="line">                        <span class="keyword">if</span> (written_size + SUMMARY_SIZE &lt;= PAGE_CACHE_SIZE -</span><br><span class="line">                                                        SUM_FOOTER_SIZE)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        page = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">                f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                        <span class="type">block_t</span> blkaddr, <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, end;</span><br><span class="line">        <span class="comment">// type 在这里传入 CURSEG_HOT_DATA</span></span><br><span class="line">        <span class="keyword">if</span> (IS_DATASEG(type))</span><br><span class="line">                end = type + NR_CURSEG_DATA_TYPE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                end = type + NR_CURSEG_NODE_TYPE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历DATA TYPE curseg</span></span><br><span class="line">        <span class="comment">// 总共三种温度，各写一个page，按[HOT, WARM, COLD]顺序排放在blkaddr后面</span></span><br><span class="line">        <span class="comment">// 如上面compact写入分析，blkaddr要么定位在ckpt后面，要么在orphan后面</span></span><br><span class="line">        <span class="keyword">for</span> (i = type; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">sum</span> =</span> CURSEG_I(sbi, i);</span><br><span class="line">                mutex_lock(&amp;sum-&gt;curseg_mutex);</span><br><span class="line">                write_sum_page(sbi, sum-&gt;sum_blk, blkaddr + (i - type));</span><br><span class="line">                mutex_unlock(&amp;sum-&gt;curseg_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ignotusjee.github.io">柳苏明</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ignotusjee.github.io/2024/10/18/f2fs-process/">https://ignotusjee.github.io/2024/10/18/f2fs-process/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ignotusjee.github.io" target="_blank">Blognotus</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a><a class="post-meta__tags" href="/tags/sys/">sys</a><a class="post-meta__tags" href="/tags/Linux-kernel/">Linux kernel</a><a class="post-meta__tags" href="/tags/f2fs/">f2fs</a></div><div class="post-share"><div class="social-share" data-image="/img/pic14.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="prev-post pull-left" href="/2024/11/27/linux-list/" title="Linux list.h 浅析"><img class="cover" src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux list.h 浅析</div></div></a><a class="next-post pull-right" href="/2024/10/18/Linux-Debug/" title="编译调试内核方法"><img class="cover" src="/img/8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编译调试内核方法</div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a href="/2023/02/24/2023-2-24-%E7%97%85%E6%AF%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" title="2023-2-24-病毒学习笔记~文件系统"><img class="cover" src="/img/19.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-24</div><div class="title">2023-2-24-病毒学习笔记~文件系统</div></div></a><a href="/2024/10/18/Linux-Debug/" title="编译调试内核方法"><img class="cover" src="/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="title">编译调试内核方法</div></div></a><a href="/2024/11/27/linux-list/" title="Linux list.h 浅析"><img class="cover" src="/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-27</div><div class="title">Linux list.h 浅析</div></div></a><a href="/2024/10/18/PCIE-NOTE-1/" title="PCIE学习笔记（一）PCI"><img class="cover" src="/img/pic14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-18</div><div class="title">PCIE学习笔记（一）PCI</div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">柳苏明</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IgnotusJee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">f2fs 文件组织形式和典型流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">重要结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#directory-entry"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">directory entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#directory-block"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">directory block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bucket"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">bucket</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">文件操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-open"><span class="toc-number">1.2.1.</span> <span class="toc-text">file open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-operation"><span class="toc-number">1.2.2.</span> <span class="toc-text">write operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-operation"><span class="toc-number">1.2.3.</span> <span class="toc-text">read operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#garbage-collection"><span class="toc-number">1.2.4.</span> <span class="toc-text">garbage collection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Background-GC"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Background GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Victim-selection"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">Victim selection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-procedure"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">GC procedure</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recovery"><span class="toc-number">1.2.5.</span> <span class="toc-text">Recovery</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/27/linux-list/" title="Linux list.h 浅析"><img src="/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux list.h 浅析"/></a><div class="content"><a class="title" href="/2024/11/27/linux-list/" title="Linux list.h 浅析">Linux list.h 浅析</a><time datetime="2024-11-27T15:08:20.000Z" title="发表于 2024-11-27 23:08:20">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/f2fs-process/" title="F2FS 文件流程浅析"><img src="/img/pic14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="F2FS 文件流程浅析"/></a><div class="content"><a class="title" href="/2024/10/18/f2fs-process/" title="F2FS 文件流程浅析">F2FS 文件流程浅析</a><time datetime="2024-10-18T14:26:27.000Z" title="发表于 2024-10-18 22:26:27">2024-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/Linux-Debug/" title="编译调试内核方法"><img src="/img/8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译调试内核方法"/></a><div class="content"><a class="title" href="/2024/10/18/Linux-Debug/" title="编译调试内核方法">编译调试内核方法</a><time datetime="2024-10-18T14:22:35.000Z" title="发表于 2024-10-18 22:22:35">2024-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/PCIE-NOTE-1/" title="PCIE学习笔记（一）PCI"><img src="/img/pic14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PCIE学习笔记（一）PCI"/></a><div class="content"><a class="title" href="/2024/10/18/PCIE-NOTE-1/" title="PCIE学习笔记（一）PCI">PCIE学习笔记（一）PCI</a><time datetime="2024-10-18T14:17:25.000Z" title="发表于 2024-10-18 22:17:25">2024-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/2023-8-16%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="深度学习笔记II 多层感知机"><img src="/img/pic24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深度学习笔记II 多层感知机"/></a><div class="content"><a class="title" href="/2023/08/16/2023-8-16%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/" title="深度学习笔记II 多层感知机">深度学习笔记II 多层感知机</a><time datetime="2023-08-16T08:26:34.000Z" title="发表于 2023-08-16 16:26:34">2023-08-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/pic6.png);"><div id="footer-wrap"><div class="copyright">&copy;2024 By 柳苏明</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'MHozXOxqywpXLAwxn97T8VnD-MdYXbMMI',
      appKey: 'cf4NSw5K8ck4mowmdGGtoxvq',
      avatar: 'identicon',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><div class="aplayer no-destroy" data-id="7876594346" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-mini="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: true,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search what you want" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>