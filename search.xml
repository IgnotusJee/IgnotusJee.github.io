<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux list.h 浅析</title>
      <link href="/2024/11/27/linux-list/"/>
      <url>/2024/11/27/linux-list/</url>
      
        <content type="html"><![CDATA[<p>#　Linux 中的 list.h</p><p>基于内核版本<code>5.15.158</code>分析，该文件位于<code>/include/linux/list.h</code>，是在 Linux 中的众多数据结构中使用的双向链表结构。</p><h2 id="原理架构">原理架构</h2><p><code>/include/linux/types.h</code>中定义了链表节点<code>struct list_head</code>，包含了指向前后两个节点的双向指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别于常用的 List 节点存储节点对象地址的形式，<code>list.h</code>这个双向链表的使用方式是将<code>struct list_head</code>声明为节点数据结构的变量成员。这种方式的好处是不再需要单独的一个链表头对象才能访问到各个节点。当索引到某个节点时，通过成员相对节点数据结构的结构体地址的偏移来从<code>struct list_head</code>还原这个节点的地址。</p><p>例如，在 Linux 的 pcb 结构<code>struct task_struct</code>中就有多个<code>struct list_head</code>成员，将一个 pcb 实例放在多个功能不同的链表上进行管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RCU</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rcu_node_entry</span>;</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_PREEMPT_RCU */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_RCU</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">rcu_tasks_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_RCU */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_TRACE_RCU</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">trc_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_TRACE_RCU */</span></span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作">操作</h2><p>list 的初始化有两种方式，一种是用<code>LIST_HEAD</code>宏直接定义<code>struct list_head</code>并且初始化，适用于单独使用的链表节点；另一种是使用<code>INIT_LIST_HEAD</code>初始化声明好的<code>struct list_head</code>，两种初始化都会将节点的双向指针指向自己。</p><p>list 提供的操作主要为<code>add</code>、<code>del</code>、<code>replace</code>等，其功能简单如字面意思。值得注意的是有些功能有一些特别的地方，如在<code>add</code>操作中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">next-&gt;prev = new;</span><br><span class="line">new-&gt;next = next;</span><br><span class="line">new-&gt;prev = prev;</span><br><span class="line">WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span> &#123;</span><br><span class="line">__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>head-&gt;next</code>应该是一个多核同步的变量（即实质 volatile 的），为防止编译器优化将其放入寄存器或者 cache，使用这个宏使其这次写是直接写入内存的，保持并行场景中更严格的内存模型。</p><p>另外，在<code>del</code>操作中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span> &#123;</span><br><span class="line">__list_del_entry(entry);</span><br><span class="line">entry-&gt;next = LIST_POISON1;</span><br><span class="line">entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 内核为防止访问未初始化或者已删除的 entry，会将这些 entry 的两个指针指向两个非法的预设值，称为<code>POISON</code>，对其进行访问会触发 page fault（dmesg 应该里面会报 page not present 的错），这样也可以区分访问非法指针的错误出现在代码的哪里。</p><p><code>list.h</code>中也有用于遍历链表的宏，可以方便地替换手写的循环，也有 lock-free 的 rcu 版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each-iterate over a list</span></span><br><span class="line"><span class="comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">for (pos = (head)-&gt;next; !list_is_head(pos, (head)); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_rcu - Iterate over a list in an RCU-safe fashion</span></span><br><span class="line"><span class="comment"> * @pos:the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_rcu(pos, head)  \</span></span><br><span class="line"><span class="meta">for (pos = rcu_dereference((head)-&gt;next); \</span></span><br><span class="line"><span class="meta">     !list_is_head(pos, (head)); \</span></span><br><span class="line"><span class="meta">     pos = rcu_dereference(pos-&gt;next))</span></span><br></pre></td></tr></table></figure><h2 id="hlist">hlist</h2><p>上述均说的是 list，其实<code>list.h</code>中还有一种哈希链表 hlist，它的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>hlist_node::pprev</code>指向上一个节点的 next 指针，由于哈希链表有异质的链表头，而<code>struct hlist_head</code>和<code>struct hlist_node</code>在起始地址都有相同的成员<code>struct hlist_node*</code>，所以这个双重指针可以做到无论节点还是链表头做到操作的统一并且节约空间。</p><h2 id="参考资料">参考资料</h2><p><a href="https://elixir.bootlin.com/linux/v5.15.158/source/include/linux/list.h#L274">list.h - include/linux/list.h - Linux source code v5.15.158 - Bootlin Elixir Cross Referencer</a></p><p><a href="https://blog.csdn.net/Adrian503/article/details/106921769">WRITE_ONCE READ_ONCE 函数的介绍与使用_wirte once-CSDN博客</a></p><p><a href="https://blog.csdn.net/hs794502825/article/details/24597773">Linux 内核 hlist 详解-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> sys </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sys </tag>
            
            <tag> Linux kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F2FS 文件流程浅析</title>
      <link href="/2024/10/18/f2fs-process/"/>
      <url>/2024/10/18/f2fs-process/</url>
      
        <content type="html"><![CDATA[<p>本文简要梳理了 f2fs 文件系统的组织方式和操作流程。</p><span id="more"></span><h1>f2fs 文件组织形式和典型流程</h1><h2 id="重要结构">重要结构</h2><h3 id="文件结构">文件结构</h3><p>文件数据的组织方式一般时被设计为inode-data模式，即 每一个文件都具有一个inode，这个inode记录data的组织关系，这个关系称为<strong>文件结构</strong>。例如用户需要访问A文件的第1000个字节，系统就会先根据A文件的路径找到的A的inode，然后从inode找到第1000个字节所在的物理地址，然后从磁盘读取出来。那么F2FS的文件结构是怎么样的呢?</p><p><img src="/img/Artical/f2fs/inode-blockmap.png" alt=""></p><p>如上图，F2FS中的一个inode，包含两个主要部分: metadata部分，和数据块寻址部分。我们重点观察数据块寻址部分，分析inode时如何将数据块索引出来。在图中，数据块寻址部分包含direct pointers，single-indirect，double-indirect，以及triple-indirect。它们的含义分别是：</p><p><strong>direct pointer:</strong> inode内直接指向数据块(图右上角Data)的地址数组，即<strong>inode-&gt;data模式</strong>。</p><p><strong>single-indirect pointer:</strong> inode记录了两个single-indirect pointer(图右上角Direct node)，每一个single-indirect pointer存储了多个数据块的地址，即<strong>inode-&gt;direct_node-&gt;data模式</strong>。</p><p><strong>double-indirect:</strong> inode记录了两个double-indirect pointer(图右上角indirect node)，每一个double-indirect pointer记录了许多single-indirect pointer，每一个single-indirect pointer指向了数据块，即<strong>inode-&gt;indirect_node-&gt;direct_node-&gt;data模式</strong>。</p><p><strong>triple-indirect:</strong> inode记录了一个triple-indirect pointer(图右上角indirect node)，每一个triple-indirect pointer记录了许多double-indirect pointer，每一个double-indirect pointer记录了许多single-indirect pointer，最后每一个single-indirect pointer指向了数据块。即<strong>inode-&gt;indirect_node-&gt;indirect_node-&gt;direct_node-&gt;data模式</strong>。</p><p>因此，我们可以发现，F2FS的inode结构采取indirect_node，首先在inode内部寻找物理地址，如果找不到再去direct_node找，层层深入。</p><h3 id="目录结构">目录结构</h3><p><img src="/img/Artical/f2fs/dir-entries.jpeg" alt="directory structure"></p><h4 id="directory-entry">directory entry</h4><p>每个目录 entry 包括 hash / ino / len / type 四个成员，占用 11 bytes。每个 entry 代表一个子目录、符号链接或者普通文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A directory entry occupies 11 bytes, which consists of the following attributes.</span><br><span class="line"> </span><br><span class="line">- hash          hash value of the file name</span><br><span class="line">- ino           inode number</span><br><span class="line">- len           the length of file name</span><br><span class="line">- type          file type such as directory, symlink, etc</span><br></pre></td></tr></table></figure><h4 id="directory-block">directory block</h4><p>专门存储 directory entry 的 block 叫做 diretory block。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A dentry block consists of 214 dentry slots and file names. Therein a bitmap is</span><br><span class="line">used to represent whether each dentry is valid or not. A dentry block occupies</span><br><span class="line">4KB with the following composition.</span><br><span class="line"> </span><br><span class="line">  Dentry Block(4 K) = bitmap (27 bytes) + reserved (3 bytes) +</span><br><span class="line">                      dentries(11 * 214 bytes) + file name (8 * 214 bytes)</span><br><span class="line"> </span><br><span class="line">+--------+----------+----------+------------+</span><br><span class="line">  | bitmap | reserved | dentries | file names |</span><br><span class="line">  +--------+----------+----------+------------+</span><br><span class="line">  [Dentry Block: 4KB] .   .</span><br><span class="line">                 .               .</span><br><span class="line">            .                          .</span><br><span class="line">            +------+------+-----+------+</span><br><span class="line">            | hash | ino  | len | type |</span><br><span class="line">            +------+------+-----+------+</span><br><span class="line">            [Dentry Structure: 11 bytes]</span><br></pre></td></tr></table></figure><h4 id="bucket">bucket</h4><p>很容易想到目录结构是一系列的哈希表连续地存储在一个文件中，每个哈希表具有一组相当大的 buckets。查找过程从第一个哈希表到下一个哈希表，在每一个阶段对合适的bucket 执行线性查找，直到找到文件名或者查找到最后的那个哈希表。在查找过程中，在合适的 bucket 中的任意空闲空间都会被记录，以防需要创建文件名的时候用到。</p><p>F2FS 对目录结构实现了多级哈希表，每一级都有一个使用专用数字的哈希 bucket 的哈希表，如下所示。注意，“A(2B)”表示一个哈希 bucket 包含两个数据块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">----------------------</span><br><span class="line">A : bucket    哈希bucket</span><br><span class="line">B : block     数据块</span><br><span class="line">N : MAX_DIR_HASH_DEPTH   最大目录哈希层级</span><br><span class="line">----------------------</span><br><span class="line">level #0:   A(2B)</span><br><span class="line">level #1:   A(2B) - A(2B)</span><br><span class="line">level #2:   A(2B) - A(2B) - A(2B) - A(2B)</span><br><span class="line">     .       .       .       .       .</span><br><span class="line">level #N/2:  A(2B) - A(2B) - A(2B) - A(2B) - A(2B) - ... - A(2B)</span><br><span class="line">     .        .       .       .       .</span><br><span class="line">level #N:   A(4B) - A(4B) - A(4B) - A(4B) - A(4B) - ... - A(4B)</span><br></pre></td></tr></table></figure><p><img src="/img/Artical/f2fs/bucket-structure.jpeg" alt="bucket structure"></p><p>F2FS 在目录中查找文件名时，首先计算文件名的哈希值，然后在 level #0 中扫描哈希值查找包含文件名和文件的 inode 的目录项。如果没有找到，F2FS在 level #1 中扫描下一个哈希表，用这种方式，F2FS 以递增的方式扫描每个 level 的哈希表（如果上一 level 中没有查找到结果），在每个 level中，F2FS 仅需要扫描一个bucket，而该 bucket 的号是由文件名的哈希值与该 level 中的 buckets 个数的相除取余得到的。也就是每个 level 中需要扫描的一个 bucket 由下式确定的，查找复杂度是 O(log(# of files))</p><blockquote><p>bucket number to scan in level #n = (hash value) % (# of buckets in level #)</p></blockquote><h2 id="文件操作流程">文件操作流程</h2><h3 id="file-open">file open</h3><p>函数调用流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">open sys_call -&gt;</span><br><span class="line">    do_sys_open -&gt;</span><br><span class="line">        do_sys_openat2 -&gt;</span><br><span class="line">            get_unused_fd_flags</span><br><span class="line">            do_filp_open -&gt;</span><br><span class="line">                path_openat -&gt;</span><br><span class="line">                    alloc_empty_file</span><br><span class="line">                    while(</span><br><span class="line">                        link_path_walk</span><br><span class="line">                        open_last_lookups [lookup and maybe create] -&gt;</span><br><span class="line">                            lookup_open -&gt;</span><br><span class="line">                              d_lookup [find dentry in cache]</span><br><span class="line">                              dir_inode-&gt;i_op-&gt;lookup -&gt;</span><br><span class="line">                                  f2fs_lookup</span><br><span class="line">                              dir_inode-&gt;i_op-&gt;create -&gt;</span><br><span class="line">                                  f2fs_create</span><br><span class="line">                    )</span><br><span class="line">                    do_open -&gt;</span><br><span class="line">                        vfs_open -&gt;</span><br><span class="line">                                do_dentry_open -&gt;</span><br><span class="line">                                        f2fs_file_open</span><br><span class="line">            fsnotify_open and fd_install [load fd in cur task_struct]</span><br></pre></td></tr></table></figure><p>相关回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_create</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="type">nid_t</span> ino = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 inode 实例：kmemcache 分配 inode，且从 freelist 申请 nid</span></span><br><span class="line">        inode = f2fs_new_inode(dir, mode);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!test_opt(sbi, DISABLE_EXT_IDENTIFY))</span><br><span class="line">                <span class="comment">// 创建时为 cold</span></span><br><span class="line">                set_cold_file(sbi, inode, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 赋值 iop fop aop</span></span><br><span class="line">        inode-&gt;i_op = &amp;f2fs_file_inode_operations;</span><br><span class="line">        inode-&gt;i_fop = &amp;f2fs_file_operations;</span><br><span class="line">        inode-&gt;i_mapping-&gt;a_ops = &amp;f2fs_dblock_aops;</span><br><span class="line">        ino = inode-&gt;i_ino;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联到 dentry</span></span><br><span class="line">        <span class="comment">// 这里会更新 parent metadata</span></span><br><span class="line">        err = f2fs_add_link(dentry, inode);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 sbi 获取 nm_i，并从中关联的 free list 删除对应空间，让给 ino 使用</span></span><br><span class="line">        alloc_nid_done(sbi, ino);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sbi-&gt;por_doing)</span><br><span class="line">                <span class="comment">// VFS 层函数，使用 inode 信息，构造完整的 dentry</span></span><br><span class="line">                d_instantiate(dentry, inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">        clear_nlink(inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">        iput(inode);</span><br><span class="line">        alloc_nid_failed(sbi, ino);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 inode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">f2fs_new_inode</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(sb);</span><br><span class="line">        <span class="type">nid_t</span> ino;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="type">bool</span> nid_free = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VFS 函数，通过 kmalloc 返回 inode 实例</span></span><br><span class="line">        <span class="comment">// 内部会调用 s_op-&gt;alloc_inode() 进行初始化</span></span><br><span class="line">        <span class="comment">// 对应到 F2FS 就是 f2fs_alloc_inode()</span></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        <span class="keyword">if</span> (!inode)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, NODE_NEW);</span><br><span class="line">        <span class="comment">// 分配 inode 号，后续存放于 inode-&gt;i_ino，也就是 node id</span></span><br><span class="line">        <span class="keyword">if</span> (!alloc_nid(sbi, &amp;ino)) &#123;</span><br><span class="line">                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                err = -ENOSPC;</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_uid = current_fsuid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dir-&gt;i_mode &amp; S_ISGID) &#123;</span><br><span class="line">                inode-&gt;i_gid = dir-&gt;i_gid;</span><br><span class="line">                <span class="keyword">if</span> (S_ISDIR(mode))</span><br><span class="line">                        mode |= S_ISGID;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                inode-&gt;i_gid = current_fsgid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_ino = ino;</span><br><span class="line">        inode-&gt;i_mode = mode;</span><br><span class="line">        inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">        inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_generation = sbi-&gt;s_next_generation++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 VFS 层的函数</span></span><br><span class="line">        <span class="comment">// inode 插入到 VFS 层私有的 inode_hashtable，自身关联 inode-&gt;i_hash</span></span><br><span class="line">        <span class="comment">// 这样以后可以在内存中通过 inode 号快速查找到 inode</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// 区分 inode number（ino）和 node number（nid）</span></span><br><span class="line">        <span class="comment">// inode number 是 VFS 可以访问的，我个人理解是一个 file 对应一个 inode number</span></span><br><span class="line">        <span class="comment">// 但是 F2FS 是维护 node number 来完成寻址（用一个 ID 来替代绝对地址，解决 wandering tree）</span></span><br><span class="line">        <span class="comment">// 因此只要需要寻址的 node block 都会有一个 nid（相比之下 data block 不需要 nid）</span></span><br><span class="line">        <span class="comment">// 这里的交集在于 ino 的分配也是通过 nid 得到的（见上方，alloc_nid(..., &amp;ino)）</span></span><br><span class="line">        <span class="comment">// nid == ino 表明这是一个 inode，反之则表示是一个 direct_node 或者 indirect_node</span></span><br><span class="line">        err = insert_inode_locked(inode);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                err = -EINVAL;</span><br><span class="line">                nid_free = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记脏页，以后回写</span></span><br><span class="line">        mark_inode_dirty(inode);</span><br><span class="line">        <span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">        clear_nlink(inode);</span><br><span class="line">        unlock_new_inode(inode);</span><br><span class="line">fail:</span><br><span class="line">        iput(inode);</span><br><span class="line">        <span class="keyword">if</span> (nid_free)</span><br><span class="line">                alloc_nid_failed(sbi, ino);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，f2fs_new_inode() 有以下流程：</p><ol><li>通过 VFS 层 new_inode() 通过 kmalloc 获得 inode 实例</li><li>填充必要的具体文件系统参数到 inode</li><li>alloc_nid() 分配 inode-&gt;ino</li><li>inode 插入到 VFS 层私有的 inode_hashtable，自身关联 inode-&gt;i_hash</li><li>标记 inode 为 dirty</li><li>返回 inode 实例</li></ol><p>分配 nid：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this function returns success, caller can obtain a new nid</span></span><br><span class="line"><span class="comment"> * from second parameter of this function.</span></span><br><span class="line"><span class="comment"> * The returned nid could be used ino as well as nid when inode is created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">alloc_nid</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">nid_t</span> *nid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">free_nid</span> *<span class="title">i</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">retry:</span><br><span class="line">        mutex_lock(&amp;nm_i-&gt;build_lock);</span><br><span class="line">        <span class="comment">// fcnt 含义：the number of free node id</span></span><br><span class="line">        <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                <span class="comment">/* scan NAT in order to build free nid list */</span></span><br><span class="line">                <span class="comment">// 没有 free node 就需要需要通过 NAT 构建</span></span><br><span class="line">                build_free_nids(sbi);</span><br><span class="line">                <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                        mutex_unlock(&amp;nm_i-&gt;build_lock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;nm_i-&gt;build_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We check fcnt again since previous check is racy as</span></span><br><span class="line"><span class="comment">         * we didn&#x27;t hold free_nid_list_lock. So other thread</span></span><br><span class="line"><span class="comment">         * could consume all of free nids.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">        <span class="keyword">if</span> (!nm_i-&gt;fcnt) &#123;</span><br><span class="line">                spin_unlock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BUG_ON(list_empty(&amp;nm_i-&gt;free_nid_list));</span><br><span class="line">        <span class="comment">// 遍历 freelist 查找 free_nid</span></span><br><span class="line">        list_for_each(this, &amp;nm_i-&gt;free_nid_list) &#123;</span><br><span class="line">                i = list_entry(this, <span class="keyword">struct</span> free_nid, <span class="built_in">list</span>);</span><br><span class="line">                <span class="comment">// 用了这个 i，后续 i-&gt;state 改为 NID_ALLOC</span></span><br><span class="line">                <span class="keyword">if</span> (i-&gt;state == NID_NEW)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BUG_ON(i-&gt;state != NID_NEW);</span><br><span class="line">        *nid = i-&gt;nid;</span><br><span class="line">        i-&gt;state = NID_ALLOC;</span><br><span class="line">        nm_i-&gt;fcnt--;</span><br><span class="line">        spin_unlock(&amp;nm_i-&gt;free_nid_list_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nid freelist 不一定是完整的，当 free nid 不够了的时候就会重新进行构建。</p><p>关联 dentry，通过特定的哈希算法定位并初始化 dentry，更新 parent inode 的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_add_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> bit_pos;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> current_depth;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bidx, block;</span><br><span class="line">        <span class="type">f2fs_hash_t</span> dentry_hash;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">de</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nbucket, nblock;</span><br><span class="line">        <span class="comment">// parent directory 对应的 inode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(dir-&gt;i_sb);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name = dentry-&gt;d_name.name;</span><br><span class="line">        <span class="type">size_t</span> namelen = dentry-&gt;d_name.len;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">dentry_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dentry_block</span> *<span class="title">dentry_blk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// #define GET_DENTRY_SLOTS(x)  ((x + F2FS_NAME_LEN - 1) &gt;&gt; F2FS_NAME_LEN_BITS)</span></span><br><span class="line">        <span class="type">int</span> slots = GET_DENTRY_SLOTS(namelen);</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 filename 作为 hash key</span></span><br><span class="line">        dentry_hash = f2fs_dentry_hash(name, dentry-&gt;d_name.len);</span><br><span class="line">        level = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录能到达的最高 depth</span></span><br><span class="line">        current_depth = F2FS_I(dir)-&gt;i_current_depth;</span><br><span class="line">        <span class="comment">// 如果和最近访问的文件哈希冲突，重置最近访问文件的 hash 并从最近访问文件的 level 开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (F2FS_I(dir)-&gt;chash == dentry_hash) &#123;</span><br><span class="line">                level = F2FS_I(dir)-&gt;clevel;</span><br><span class="line">                F2FS_I(dir)-&gt;chash = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入到多级哈希表的查找过程</span></span><br><span class="line">start:</span><br><span class="line">        <span class="keyword">if</span> (current_depth == MAX_DIR_HASH_DEPTH)</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase the depth, if required */</span></span><br><span class="line">        <span class="keyword">if</span> (level == current_depth)</span><br><span class="line">                ++current_depth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按公式计算 bucket 数目</span></span><br><span class="line">        nbucket = dir_buckets(level);</span><br><span class="line">        <span class="comment">// 计算 block 数目</span></span><br><span class="line">        nblock = bucket_blocks(level);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定位 block index</span></span><br><span class="line">        bidx = dir_block_index(level, (le32_to_cpu(dentry_hash) % nbucket));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在当前 bucket 中遍历 block</span></span><br><span class="line">        <span class="keyword">for</span> (block = bidx; block &lt;= (bidx + nblock - <span class="number">1</span>); block++) &#123;</span><br><span class="line">                mutex_lock_op(sbi, DENTRY_OPS);</span><br><span class="line">                <span class="comment">// 为 index = block 分配对应的 data page</span></span><br><span class="line">                dentry_page = get_new_data_page(dir, block, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (IS_ERR(dentry_page)) &#123;</span><br><span class="line">                        mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">                        <span class="keyword">return</span> PTR_ERR(dentry_page);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// TODO 临时映射</span></span><br><span class="line">                <span class="comment">// 往 dentry_blk 写入数据，然后对 dentry_page 标记 dirty 就能刷入外存</span></span><br><span class="line">                dentry_blk = kmap(dentry_page);</span><br><span class="line">                bit_pos = room_for_filename(dentry_blk, slots);</span><br><span class="line">                <span class="comment">// NR_DENTRY_IN_BLOCK = 214，一个 dentry block 含有 214 个 dentry slot</span></span><br><span class="line">                <span class="keyword">if</span> (bit_pos &lt; NR_DENTRY_IN_BLOCK)</span><br><span class="line">                        <span class="comment">// 定位成功，挑出循环</span></span><br><span class="line">                        <span class="keyword">goto</span> add_dentry;</span><br><span class="line"></span><br><span class="line">                kunmap(dentry_page);</span><br><span class="line">                f2fs_put_page(dentry_page, <span class="number">1</span>);</span><br><span class="line">                mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move to next level to find the empty slot for new dentry */</span></span><br><span class="line">        <span class="comment">// 失败定位，继续循环走更高层</span></span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">goto</span> start;</span><br><span class="line"><span class="comment">// 定位成功</span></span><br><span class="line">add_dentry:</span><br><span class="line">        <span class="comment">// 提供 inode 对应的 page（通用函数 grab_cache_page()）和对应的 aops</span></span><br><span class="line">        err = init_inode_metadata(inode, dentry);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">        wait_on_page_writeback(dentry_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dentry</span></span><br><span class="line">        de = &amp;dentry_blk-&gt;dentry[bit_pos];</span><br><span class="line">        de-&gt;hash_code = dentry_hash;</span><br><span class="line">        de-&gt;name_len = cpu_to_le16(namelen);</span><br><span class="line">        <span class="built_in">memcpy</span>(dentry_blk-&gt;filename[bit_pos], name, namelen);</span><br><span class="line">        de-&gt;ino = cpu_to_le32(inode-&gt;i_ino);</span><br><span class="line">        set_de_type(de, inode);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; slots; i++)</span><br><span class="line">                test_and_set_bit_le(bit_pos + i, &amp;dentry_blk-&gt;dentry_bitmap);</span><br><span class="line">        set_page_dirty(dentry_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dir 是 parent inode</span></span><br><span class="line">        <span class="comment">// 更新 dir 与之关联的信息</span></span><br><span class="line">        update_parent_metadata(dir, inode, current_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update parent inode number before releasing dentry page */</span></span><br><span class="line">        F2FS_I(inode)-&gt;i_pino = dir-&gt;i_ino;</span><br><span class="line">fail:</span><br><span class="line">        kunmap(dentry_page);</span><br><span class="line">        f2fs_put_page(dentry_page, <span class="number">1</span>);</span><br><span class="line">        mutex_unlock_op(sbi, DENTRY_OPS);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2fs_lookup 中也实现了上述的流程。（实际上我看的更新的内核版本，目录项查找流程已经写进 __f2fs_find_entry 函数里了）</p><h3 id="write-operation">write operation</h3><p>f2fs 在 vfs 的注册函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">f2fs_file_operations</span> =</span> &#123;</span><br><span class="line">        .write          = do_sync_write,</span><br><span class="line">        .aio_write      = generic_file_aio_write,</span><br><span class="line">        .splice_write   = generic_file_splice_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">f2fs_dblock_aops</span> =</span> &#123;</span><br><span class="line">        .writepage      = f2fs_write_data_page,</span><br><span class="line">        .writepages     = f2fs_write_data_pages,</span><br><span class="line">        .write_begin    = f2fs_write_begin,</span><br><span class="line">        .write_end      = nobh_write_end,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>f2fs_write_begin()</code> 为写入操作准备了 page，并通过 <code>pagep</code> 指向它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_begin</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                <span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">pgoff_t</span> index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) pos) &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> <span class="title">dn</span>;</span></span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* for nobh_write_end */</span></span><br><span class="line">        *fsdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 相关</span></span><br><span class="line">        f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化要写的 page（Find or create a page at the given pagecache position）</span></span><br><span class="line">        <span class="comment">// 这里保证存在于 page cache 中</span></span><br><span class="line">        page = grab_cache_page_write_begin(mapping, index, flags);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        *pagep = page;</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, DATA_NEW);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dnode，用于找到物理地址（data_blkaddr）</span></span><br><span class="line">        set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        err = get_dnode_of_data(&amp;dn, index, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line">                f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dn.data_blkaddr == NULL_ADDR) &#123;</span><br><span class="line">                err = reserve_new_block(&amp;dn);</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        f2fs_put_dnode(&amp;dn);</span><br><span class="line">                        mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f2fs_put_dnode(&amp;dn);</span><br><span class="line"></span><br><span class="line">        mutex_unlock_op(sbi, DATA_NEW);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((len == PAGE_CACHE_SIZE) || PageUptodate(page))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pos &amp; PAGE_CACHE_MASK) &gt;= i_size_read(inode)) &#123;</span><br><span class="line">                <span class="type">unsigned</span> start = pos &amp; (PAGE_CACHE_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="type">unsigned</span> end = start + len;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Reading beyond i_size is simple: memset to zero */</span></span><br><span class="line">                zero_user_segments(page, <span class="number">0</span>, start, end, PAGE_CACHE_SIZE);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// append 操作</span></span><br><span class="line">        <span class="keyword">if</span> (dn.data_blkaddr == NEW_ADDR) &#123;</span><br><span class="line">                <span class="comment">// 填 0</span></span><br><span class="line">                zero_user_segment(page, <span class="number">0</span>, PAGE_CACHE_SIZE);</span><br><span class="line">        <span class="comment">// overwrite 操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 读出旧的内容</span></span><br><span class="line">                err = f2fs_readpage(sbi, page, dn.data_blkaddr, READ_SYNC);</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SetPageUptodate(page);</span><br><span class="line">        clear_cold_data(page);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2fs_write_begin() 这个过程会被 VFS 调用，然后得到 page 的 VFS 将 write(fd, buf, size) 需要写入的 buf 内容拷贝到该 page。VFS 拷贝完成后，还会调用 write_end() 作为写入操作的结束调用，主要是为此前已上锁的 page 进行解锁</p><p>普通文件的默认写策略是 writeback，VFS 通过提供 writepage() 等定制点来实现具体文件系统的写回操作。前面已提到 F2FS 使用 f2fs_write_data_page() 和 f2fs_write_data_pages() 来完成这个操作</p><p>写回线程的调用路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bdi_writeback_thread</span><br><span class="line">  wb_do_writeback</span><br><span class="line">    wb_writeback</span><br><span class="line">      __writeback_single_inode</span><br><span class="line">        do_writepages</span><br><span class="line">          a_ops-&gt;writepages</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_data_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> writeback_control *wbc)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="type">loff_t</span> i_size = i_size_read(inode);</span><br><span class="line">        <span class="type">const</span> <span class="type">pgoff_t</span> end_index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) i_size) &gt;&gt; PAGE_CACHE_SHIFT;</span><br><span class="line">        <span class="type">unsigned</span> offset;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;index &lt; end_index)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the offset is out-of-range of file size,</span></span><br><span class="line"><span class="comment">         * this page does not have to be written to disk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 找到要写的地方</span></span><br><span class="line">        offset = i_size &amp; (PAGE_CACHE_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((page-&gt;index &gt;= end_index + <span class="number">1</span>) || !offset) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                        dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                        inode_dec_dirty_dents(inode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">goto</span> unlock_out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [offset, SIZE) 先清零</span></span><br><span class="line">        zero_user_segment(page, offset, PAGE_CACHE_SIZE);</span><br><span class="line">out:</span><br><span class="line">        <span class="comment">// 如果正在做 recovery，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;por_doing)</span><br><span class="line">                <span class="keyword">goto</span> redirty_out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// writeback controller 的特性</span></span><br><span class="line">        <span class="comment">// for_reclaim 在 shrink_page_list() 中被置为 1</span></span><br><span class="line">        <span class="comment">// 也就是说内存吃紧且高频数据可能被跳过</span></span><br><span class="line">        <span class="keyword">if</span> (wbc-&gt;for_reclaim &amp;&amp; !S_ISDIR(inode-&gt;i_mode) &amp;&amp; !is_cold_data(page))</span><br><span class="line">                <span class="keyword">goto</span> redirty_out;</span><br><span class="line"></span><br><span class="line">        mutex_lock_op(sbi, DATA_WRITE);</span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                inode_dec_dirty_dents(inode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际的写操作</span></span><br><span class="line">        err = do_write_data_page(page);</span><br><span class="line">        <span class="comment">// 有问题就下次再来</span></span><br><span class="line">        <span class="keyword">if</span> (err &amp;&amp; err != -ENOENT) &#123;</span><br><span class="line">                wbc-&gt;pages_skipped++;</span><br><span class="line">                set_page_dirty(page);</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock_op(sbi, DATA_WRITE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wbc-&gt;for_reclaim)</span><br><span class="line">                f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == -ENOENT)</span><br><span class="line">                <span class="keyword">goto</span> unlock_out;</span><br><span class="line"></span><br><span class="line">        clear_cold_data(page);</span><br><span class="line">        unlock_page(page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!wbc-&gt;for_reclaim &amp;&amp; !S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">                f2fs_balance_fs(sbi);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unlock_out:</span><br><span class="line">        unlock_page(page);</span><br><span class="line">        <span class="keyword">return</span> (err == -ENOENT) ? <span class="number">0</span> : err;</span><br><span class="line"></span><br><span class="line">redirty_out:</span><br><span class="line">        wbc-&gt;pages_skipped++;</span><br><span class="line">        set_page_dirty(page);</span><br><span class="line">        <span class="keyword">return</span> AOP_WRITEPAGE_ACTIVATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>struct dnode_of_data</code> 是寻址用到的数据结构，用于物理地址寻址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * this structure is used as one of function parameters.</span></span><br><span class="line"><span class="comment"> * all the information are dedicated to a given direct node block determined</span></span><br><span class="line"><span class="comment"> * by the data offset in a file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span>            <span class="comment">/* vfs inode pointer */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">inode_page</span>;</span>        <span class="comment">/* its inode page, NULL is possible */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_page</span>;</span>         <span class="comment">/* cached direct node page */</span></span><br><span class="line">        <span class="type">nid_t</span> nid;                      <span class="comment">/* node id of the direct node block */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node;       <span class="comment">/* data offset in the node page */</span></span><br><span class="line">        <span class="type">bool</span> inode_page_locked;         <span class="comment">/* inode page is locked or not */</span></span><br><span class="line">        <span class="type">block_t</span> data_blkaddr;           <span class="comment">/* block address of the node block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_new_dnode</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page *ipage, <span class="keyword">struct</span> page *npage, <span class="type">nid_t</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dn, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dn));</span><br><span class="line">        dn-&gt;inode = inode;</span><br><span class="line">        dn-&gt;inode_page = ipage;</span><br><span class="line">        dn-&gt;node_page = npage;</span><br><span class="line">        dn-&gt;nid = nid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Caller should call f2fs_put_dnode(dn).</span></span><br><span class="line"><span class="comment">        早期版本代码，仅供理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_dnode_of_data</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="type">pgoff_t</span> index, <span class="type">int</span> ro)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(dn-&gt;inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">npage</span>[4];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">parent</span>;</span></span><br><span class="line">        <span class="type">int</span> offset[<span class="number">4</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> noffset[<span class="number">4</span>];</span><br><span class="line">        <span class="type">nid_t</span> nids[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> level, i;</span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心 block 寻址，callee 传回 offset[]</span></span><br><span class="line">        <span class="comment">// 得到 node 层数 level，每层的数组下标偏移 offset 和 依次排列的第几个 node 的 noffset</span></span><br><span class="line">        level = get_node_path(index, offset, noffset);</span><br><span class="line"></span><br><span class="line">        nids[<span class="number">0</span>] = dn-&gt;inode-&gt;i_ino;</span><br><span class="line">        <span class="comment">// 途径 get_node_page -&gt; read_node_page -&gt; f2fs_readpage</span></span><br><span class="line">        <span class="comment">// 读到了 inode page</span></span><br><span class="line">        npage[<span class="number">0</span>] = get_node_page(sbi, nids[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(npage[<span class="number">0</span>]))</span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(npage[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是 inode page</span></span><br><span class="line">        parent = npage[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 使用 page 和 offset 计算出 nid</span></span><br><span class="line">        <span class="comment">// 返回 (struct f2fs_node*) page_address(parent)-&gt;i.i_nid[offset[0] - NODE_DIR1_BLOCK]</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// f2fs_node 可以表现 3 种形式：inode, direct, and indirect types。这里是 inode（-&gt;i）</span></span><br><span class="line">        <span class="comment">// i_nid[5] 存放 direct(2) + indirect(2) + d_indirect(2) 的 node id</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 但这里为什么如此确定 offset[0] &gt;= NODE_DIR1_BLOCK？</span></span><br><span class="line">        <span class="comment">// 看了后期的代码是需要判断的（if level&gt;0），这里早期实现确实是个 bug</span></span><br><span class="line">        nids[<span class="number">1</span>] = get_nid(parent, offset[<span class="number">0</span>], <span class="literal">true</span>);</span><br><span class="line">        dn-&gt;inode_page = npage[<span class="number">0</span>];</span><br><span class="line">        dn-&gt;inode_page_locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get indirect or direct nodes */</span></span><br><span class="line">        <span class="comment">// 总之这里就按层级不断读页</span></span><br><span class="line">        <span class="comment">// 一些实现细节：</span></span><br><span class="line">        <span class="comment">// - 如果遇到没有 nid 的 block，那就分配（内存没有读上来？）</span></span><br><span class="line">        <span class="comment">// - page 会尝试预读（ro == true</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= level; i++) &#123;</span><br><span class="line">                <span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!nids[i] &amp;&amp; !ro) &#123;</span><br><span class="line">                        mutex_lock_op(sbi, NODE_NEW);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* alloc new node */</span></span><br><span class="line">                        <span class="keyword">if</span> (!alloc_nid(sbi, &amp;(nids[i]))) &#123;</span><br><span class="line">                                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                                err = -ENOSPC;</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        dn-&gt;nid = nids[i];</span><br><span class="line">                        <span class="comment">// 从 page cache 获取 page，如果没有对应 page，允许读页</span></span><br><span class="line">                        npage[i] = new_node_page(dn, noffset[i]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                alloc_nid_failed(sbi, nids[i]);</span><br><span class="line">                                mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 更新 parent-&gt;i.i_nid[] (if i==1) 或者 parent-&gt;in.nid[] (if i != 1)</span></span><br><span class="line">                        set_nid(parent, offset[i - <span class="number">1</span>], nids[i], i == <span class="number">1</span>);</span><br><span class="line">                        alloc_nid_done(sbi, nids[i]);</span><br><span class="line">                        mutex_unlock_op(sbi, NODE_NEW);</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ro &amp;&amp; i == level &amp;&amp; level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        npage[i] = get_node_page_ra(parent, offset[i - <span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                <span class="keyword">goto</span> release_pages;</span><br><span class="line">                        &#125;</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                        dn-&gt;inode_page_locked = <span class="literal">false</span>;</span><br><span class="line">                        unlock_page(parent);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f2fs_put_page(parent, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">                        npage[i] = get_node_page(sbi, nids[i]);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(npage[i])) &#123;</span><br><span class="line">                                err = PTR_ERR(npage[i]);</span><br><span class="line">                                f2fs_put_page(npage[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                                <span class="keyword">goto</span> release_out;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; level) &#123;</span><br><span class="line">                        parent = npage[i];</span><br><span class="line">                        nids[i + <span class="number">1</span>] = get_nid(parent, offset[i], <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是会写入到 summary entry 的 nid，也就是 parent node</span></span><br><span class="line">        <span class="comment">// 比如 direct pointer（level==0）的情况，这里就填入 ino</span></span><br><span class="line">        dn-&gt;nid = nids[level];</span><br><span class="line">        <span class="comment">// 块内偏移</span></span><br><span class="line">        dn-&gt;ofs_in_node = offset[level];</span><br><span class="line">        dn-&gt;node_page = npage[level];</span><br><span class="line">        <span class="comment">// 最终目标，知道第几层，哪个 page 以及 offset 后，对着数据结构布局解析就能得到</span></span><br><span class="line">        dn-&gt;data_blkaddr = datablock_addr(dn-&gt;node_page, dn-&gt;ofs_in_node);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">release_pages:</span><br><span class="line">        f2fs_put_page(parent, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)</span><br><span class="line">                f2fs_put_page(npage[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">release_out:</span><br><span class="line">        dn-&gt;inode_page = <span class="literal">NULL</span>;</span><br><span class="line">        dn-&gt;node_page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F2FS 的 writeback 实际靠 do_write_data_page 完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_write_data_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="type">block_t</span> old_blk_addr, new_blk_addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> <span class="title">dn</span>;</span></span><br><span class="line">        <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻址过程，得到 old_blk_addr</span></span><br><span class="line">        set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        err = get_dnode_of_data(&amp;dn, page-&gt;index, RDONLY_NODE);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">        old_blk_addr = dn.data_blkaddr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This page is already truncated */</span></span><br><span class="line">        <span class="keyword">if</span> (old_blk_addr == NULL_ADDR)</span><br><span class="line">                <span class="keyword">goto</span> out_writepage;</span><br><span class="line"></span><br><span class="line">        set_page_writeback(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If current allocation needs SSR,</span></span><br><span class="line"><span class="comment">         * it had better in-place writes for updated data.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// SSR-style 写操作</span></span><br><span class="line">        <span class="comment">// SSR 指的是 Slack Space Recycling</span></span><br><span class="line">        <span class="comment">// 含义见 f2fs/segment.h，reuses obsolete space without cleaning operations</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 也就是说这里是 in-place update</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 需要的条件 need_inplace_update() 如论文描述，</span></span><br><span class="line">        <span class="comment">// free section 数目（由 free_i 维护）少于一定阈值时满足</span></span><br><span class="line">        <span class="keyword">if</span> (old_blk_addr != NEW_ADDR &amp;&amp; !is_cold_data(page) &amp;&amp;</span><br><span class="line">                                need_inplace_update(inode)) &#123;</span><br><span class="line">                rewrite_data_page(F2FS_SB(inode-&gt;i_sb), page,</span><br><span class="line">                                                old_blk_addr);</span><br><span class="line">        <span class="comment">// 而这里是 LFS-style 的写操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write_data_page(inode, page, &amp;dn,</span><br><span class="line">                                old_blk_addr, &amp;new_blk_addr);</span><br><span class="line">                update_extent_cache(new_blk_addr, &amp;dn);</span><br><span class="line">                F2FS_I(inode)-&gt;data_version =</span><br><span class="line">                        le64_to_cpu(F2FS_CKPT(sbi)-&gt;checkpoint_ver);</span><br><span class="line">        &#125;</span><br><span class="line">out_writepage:</span><br><span class="line">        f2fs_put_dnode(&amp;dn);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的写操作是区分为原地写和追加写</p><p>In-place write：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewrite_data_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                                        <span class="type">block_t</span> old_blk_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">        submit_write_page(sbi, page, old_blk_addr, DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_write_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                                <span class="type">block_t</span> blk_addr, <span class="keyword">enum</span> page_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bdev</span> =</span> sbi-&gt;sb-&gt;s_bdev;</span><br><span class="line"></span><br><span class="line">        verify_block_addr(sbi, blk_addr);</span><br><span class="line"></span><br><span class="line">        down_write(&amp;sbi-&gt;bio_sem);</span><br><span class="line"></span><br><span class="line">        inc_page_count(sbi, F2FS_WRITEBACK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// super block 维护 DATA/NODE/META 类型的 bio[] 数组</span></span><br><span class="line">        <span class="comment">// last_block_in_bio[] 表示最后的 block 号</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[type] &amp;&amp; sbi-&gt;last_block_in_bio[type] != blk_addr - <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 不连续的 page 先提交上去</span></span><br><span class="line">                <span class="comment">// false 指的是异步提交，如果是 true 则是 SYNC</span></span><br><span class="line">                <span class="comment">// 在这个上下文中，内部大概是一个 submit_bio() 的封装</span></span><br><span class="line">                do_submit_bio(sbi, type, <span class="literal">false</span>);</span><br><span class="line">alloc_new:</span><br><span class="line">        <span class="comment">// 既然没在 sbi 初始化过程找到它的身影，那就是默认为 NULL，先分配</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 提交（submit_bio()）后，bio 也是回归到 NULL。因此上面不连续的提交后也走这个分支</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[type] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 1. kmemcache 分配 f2fs 私有数据结构 struct bio_private，用于 check point 等待唤醒</span></span><br><span class="line">                <span class="comment">// 2. 使用内核通用的 bio_alloc() 分配 bio</span></span><br><span class="line">                sbi-&gt;bio[type] = f2fs_bio_alloc(bdev, bio_get_nr_vecs(bdev));</span><br><span class="line">                sbi-&gt;bio[type]-&gt;bi_sector = SECTOR_FROM_BLOCK(sbi, blk_addr);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The end_io will be assigned at the sumbission phase.</span></span><br><span class="line"><span class="comment">                 * Until then, let bio_add_page() merge consecutive IOs as much</span></span><br><span class="line"><span class="comment">                 * as possible.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bio 合并 page</span></span><br><span class="line">        <span class="keyword">if</span> (bio_add_page(sbi-&gt;bio[type], page, PAGE_CACHE_SIZE, <span class="number">0</span>) &lt;</span><br><span class="line">                                                        PAGE_CACHE_SIZE) &#123;</span><br><span class="line">                do_submit_bio(sbi, type, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">goto</span> alloc_new;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录 last block，尽可能合并提交</span></span><br><span class="line">        sbi-&gt;last_block_in_bio[type] = blk_addr;</span><br><span class="line"></span><br><span class="line">        up_write(&amp;sbi-&gt;bio_sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_submit_bio</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                <span class="keyword">enum</span> page_type type, <span class="type">bool</span> sync)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> rw = sync ? WRITE_SYNC : WRITE;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">page_type</span> <span class="title">btype</span> =</span> type &gt; META ? META : type;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type &gt;= META_FLUSH)</span><br><span class="line">                rw = WRITE_FLUSH_FUA;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;bio[btype]) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">bio_private</span> *<span class="title">p</span> =</span> sbi-&gt;bio[btype]-&gt;bi_private;</span><br><span class="line">                p-&gt;sbi = sbi;</span><br><span class="line">                <span class="comment">// 完成后的回调</span></span><br><span class="line">                <span class="comment">// 大概是标记 writeback page 结束，以及处理 check point 细节（唤醒）</span></span><br><span class="line">                sbi-&gt;bio[btype]-&gt;bi_end_io = f2fs_end_io_write;</span><br><span class="line">                <span class="comment">// check point 操作才会有这个类型</span></span><br><span class="line">                <span class="keyword">if</span> (type == META_FLUSH) &#123;</span><br><span class="line">                        DECLARE_COMPLETION_ONSTACK(wait);</span><br><span class="line">                        p-&gt;is_sync = <span class="literal">true</span>;</span><br><span class="line">                        p-&gt;wait = &amp;wait;</span><br><span class="line">                        submit_bio(rw, sbi-&gt;bio[btype]);</span><br><span class="line">                        wait_for_completion(&amp;wait);</span><br><span class="line">                <span class="comment">// 其它类型就是一个 submit_bio() 过程</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p-&gt;is_sync = <span class="literal">false</span>;</span><br><span class="line">                        submit_bio(rw, sbi-&gt;bio[btype]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 提交完后对应 bio 就置空</span></span><br><span class="line">                sbi-&gt;bio[btype] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Append write</p><p>在追加写中，new_blkaddr 是由 callee 而非 caller 指定的，因此执行过程后调用方才能得知新的追加地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_data_page</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> dnode_of_data *dn, <span class="type">block_t</span> old_blkaddr,</span></span><br><span class="line"><span class="params">                <span class="type">block_t</span> *new_blkaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">sum</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node_info</span> <span class="title">ni</span>;</span></span><br><span class="line"></span><br><span class="line">        BUG_ON(old_blkaddr == NULL_ADDR);</span><br><span class="line">        get_node_info(sbi, dn-&gt;nid, &amp;ni);</span><br><span class="line">        <span class="comment">// 初始化 summary entry</span></span><br><span class="line">        set_summary(&amp;sum, dn-&gt;nid, dn-&gt;ofs_in_node, ni.version);</span><br><span class="line"></span><br><span class="line">        do_write_page(sbi, page, old_blkaddr,</span><br><span class="line">                        new_blkaddr, &amp;sum, DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_summary</span><span class="params">(<span class="keyword">struct</span> f2fs_summary *sum, <span class="type">nid_t</span> nid,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node, <span class="type">unsigned</span> <span class="type">char</span> version)</span></span><br><span class="line">&#123;</span><br><span class="line">        sum-&gt;nid = cpu_to_le32(nid);</span><br><span class="line">        sum-&gt;ofs_in_node = cpu_to_le16(ofs_in_node);</span><br><span class="line">        sum-&gt;version = version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_write_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                        <span class="type">block_t</span> old_blkaddr, <span class="type">block_t</span> *new_blkaddr,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> f2fs_summary *sum, <span class="keyword">enum</span> page_type p_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> old_cursegno;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回诸如 CURSEG_HOT_DATA 等类型</span></span><br><span class="line">        type = __get_segment_type(page, p_type);</span><br><span class="line">        <span class="comment">// 通过 SM_I(sbi)-&gt;curseg_array + type 得到</span></span><br><span class="line">        curseg = CURSEG_I(sbi, type);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line">        <span class="comment">// #define NEXT_FREE_BLKADDR(sbi, curseg) \</span></span><br><span class="line"><span class="comment">        //      (START_BLOCK(sbi, curseg-&gt;segno) + curseg-&gt;next_blkoff)</span></span><br><span class="line">        <span class="comment">// next_blkoff 决定新的地址</span></span><br><span class="line">        *new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);</span><br><span class="line">        old_cursegno = curseg-&gt;segno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * __add_sum_entry should be resided under the curseg_mutex</span></span><br><span class="line"><span class="comment">         * because, this function updates a summary entry in the</span></span><br><span class="line"><span class="comment">         * current summary block.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// curseg-&gt;sum_blk + next_blkoff*sizeof(f2fs_summary) 后面 memcpy 拼接 sum</span></span><br><span class="line">        __add_sum_entry(sbi, type, sum, curseg-&gt;next_blkoff);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        <span class="comment">// 简单来说，如果是 LFS-style 的话，更新 next 就是简单 +1</span></span><br><span class="line">        <span class="comment">// SSR-style 感兴趣自己看吧</span></span><br><span class="line">        __refresh_next_blkoff(sbi, curseg);</span><br><span class="line">        <span class="comment">// alloc_type: 枚举值，LFS 或者 SSR</span></span><br><span class="line">        sbi-&gt;block_count[curseg-&gt;alloc_type]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * SIT information should be updated before segment allocation,</span></span><br><span class="line"><span class="comment">         * since SSR needs latest valid block information.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 更新 SIT，主要维护对应 segment entry 的 bitmap</span></span><br><span class="line">        refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子函数判断 curseg-&gt;next_blkoff &lt; sbi-&gt;blocks_per_seg</span></span><br><span class="line">        <span class="comment">// 在 1 个 segment 内分配是有极限的。要想超越极限，那就用 2 个 semgnet</span></span><br><span class="line">        <span class="keyword">if</span> (!__has_curseg_space(sbi, type))</span><br><span class="line">                sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        locate_dirty_segment(sbi, old_cursegno);</span><br><span class="line">        locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));</span><br><span class="line">        mutex_unlock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p_type == NODE)</span><br><span class="line">                fill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* writeout dirty page into bdev */</span></span><br><span class="line">        <span class="comment">// 殊途同归，这个过程在 In-place write 已经分析过</span></span><br><span class="line">        submit_write_page(sbi, page, *new_blkaddr, p_type);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-operation">read operation</h3><p>F2FS的读流程包含了以下几个子流程:</p><ol><li>vfs_read 函数</li><li>generic_file_read_iter 函数: 根据访问类型执行不同的处理</li><li>generic_file_buffered_read: 根据用户传入的文件偏移，读取尺寸等信息，计算起始位置和页数，然后遍历每一个 page，通过预读或者单个读取的方式从磁盘中读取出来</li><li>f2fs_read_data_page &amp; f2fs_read_data_pages 函数: 从磁盘读取1个 page 或者多个 page</li><li>f2fs_mpage_readpages 函数: f2fs 读取数据的主流程</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_page</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">        <span class="type">int</span> ret = -EAGAIN;</span><br><span class="line"></span><br><span class="line">        trace_f2fs_readpage(page, DATA);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件使用特定的读取方法，这里暂不分析</span></span><br><span class="line">                ret = f2fs_read_inline_data(inode, page);</span><br><span class="line">        ret = f2fs_mpage_readpages(page-&gt;mapping, <span class="literal">NULL</span>, page, <span class="number">1</span>); <span class="comment">// 读取1个page</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_pages</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> list_last_entry(pages, <span class="keyword">struct</span> page, lru);</span><br><span class="line"></span><br><span class="line">        trace_f2fs_readpages(inode, page, nr_pages);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件是size小于1个page的文件，因此不需要进行预读，直接return 0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f2fs_mpage_readpages(mapping, pages, <span class="literal">NULL</span>, nr_pages); <span class="comment">// 读取nr_pages个page</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个参数表示一个链表头，这个链表保存了多个page，因此需要写入多个page的时候，就要传入一个List。 第三个参数表示单个page，在写入单个page的时候，通过这个函数写入。 第四个参数表示需要写入page的数目。</p><p>因此 在写入多个page的时候，需要设定第二个参数，和第四个参数，然后设定第三个参数为NULL。 在写入单个page的时候，需要设定第三个参数，和第四个参数，然后设定第二个参数为NULL。</p><p>然后分析这个函数的执行流程:</p><ol><li>遍历传入的page，得到每一个page的index以及inode</li><li>将page的inode以及index传入 f2fs_map_blocks 函数获取到该page的物理地址</li><li>将物理地址通过 submit_bio 读取该page在磁盘中的数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_mpage_readpages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> list_head *pages, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 主流程第一步 初始化map结构，这个步骤非常重要，用于获取page在磁盘的物理地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_map_blocks</span> <span class="title">map</span>;</span></span><br><span class="line">        <span class="built_in">map</span>.m_pblk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_lblk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>.m_next_pgofs = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主流程第二步 开始进行遍历，结束条件为 nr_pages 不为空</span></span><br><span class="line">        <span class="keyword">for</span> (page_idx = <span class="number">0</span>; nr_pages; page_idx++, nr_pages--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第一步，如果是读取多个page，则pages不为空，从list里面读取每一次的page结构</span></span><br><span class="line">                <span class="keyword">if</span> (pages) &#123;</span><br><span class="line">                        page = list_entry(pages-&gt;prev, <span class="keyword">struct</span> page, lru);</span><br><span class="line">                        list_del(&amp;page-&gt;lru);</span><br><span class="line">                        <span class="keyword">if</span> (add_to_page_cache_lru(page, mapping,</span><br><span class="line">                                                  page-&gt;index, GFP_KERNEL))</span><br><span class="line">                                <span class="keyword">goto</span> next_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * map.m_lblk是上一个block_in_file</span></span><br><span class="line"><span class="comment">                 * map.m_lblk + map.m_len是需要读取长度的最后一个blokaddr</span></span><br><span class="line"><span class="comment">                 * 因此这里的意思是，如果是在这个 map.m_lblk &lt; block_in_file &lt; map.m_lblk + map.m_len </span></span><br><span class="line"><span class="comment">                 * 这个范围里面，不需要map，直接将上次的blkaddr+1就是需要的地址</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 循环第二步，如果上一次找到了page，则跳到 got_it 通过bio获取page的具体数据</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED) &amp;&amp; block_in_file &gt; <span class="built_in">map</span>.m_lblk &amp;&amp;</span><br><span class="line">                        block_in_file &lt; (<span class="built_in">map</span>.m_lblk + <span class="built_in">map</span>.m_len))</span><br><span class="line">                        <span class="keyword">goto</span> got_it;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 循环第三步，使用page offset和length，通过f2fs_map_blocks获得物理地址</span></span><br><span class="line">                <span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (block_in_file &lt; last_block) &#123;</span><br><span class="line">                        <span class="built_in">map</span>.m_lblk = block_in_file; <span class="comment">// 文件的第几个block</span></span><br><span class="line">                        <span class="built_in">map</span>.m_len = last_block - block_in_file; <span class="comment">// 读取的block的长度</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">0</span>,</span><br><span class="line">                                                F2FS_GET_BLOCK_READ))</span><br><span class="line">                                <span class="keyword">goto</span> set_error_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">got_it:</span><br><span class="line">                <span class="comment">// 循环第四步，通过map的结果执行不一样的处理方式</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED)) &#123; <span class="comment">// 如果找到了地址，则计算block_nr得到磁盘的地址</span></span><br><span class="line">                        block_nr = <span class="built_in">map</span>.m_pblk + block_in_file - <span class="built_in">map</span>.m_lblk;</span><br><span class="line">                        SetPageMappedToDisk(page);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!PageUptodate(page) &amp;&amp; !cleancache_get_page(page)) &#123;</span><br><span class="line">                                SetPageUptodate(page);</span><br><span class="line">                                <span class="keyword">goto</span> confused;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取失败了，则跳过这个page</span></span><br><span class="line">                        zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                        SetPageUptodate(page);</span><br><span class="line">                        unlock_page(page);</span><br><span class="line">                        <span class="keyword">goto</span> next_page;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这部分开始用于将物理地址通过submit_bio提交到磁盘读取数据</span></span><br><span class="line"><span class="comment">                 * 由于从磁盘读取数据是一个相对耗时的操作，</span></span><br><span class="line"><span class="comment">                 * 因此显然每读取一个页就访问一次磁盘一次的方式是低效的且影响读性能的，</span></span><br><span class="line"><span class="comment">                 * 所以F2FS会尽量一次性提交多个页到磁盘读取数据，以提高性能。</span></span><br><span class="line"><span class="comment">                 * </span></span><br><span class="line"><span class="comment">                 * 这部分开始就是具体实现:</span></span><br><span class="line"><span class="comment">                 * 1. 创建一个bio(最大一次性提交256个页)</span></span><br><span class="line"><span class="comment">                 * 2. 将需要读取的页添加到这个bio中，</span></span><br><span class="line"><span class="comment">                 *     ------如果bio未满则将page添加到bio中</span></span><br><span class="line"><span class="comment">                 *     ------如果bio满了立即访问磁盘读取</span></span><br><span class="line"><span class="comment">                 *     ------如果循环结束以后，bio还是未满，则通过本函数末尾的操作提交未满的bio。</span></span><br><span class="line"><span class="comment">                 *     </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第五步，判断bio装的page是否到了设定的最大数量，如果到了最大值则先发送到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (bio &amp;&amp; (last_block_in_bio != block_nr - <span class="number">1</span>)) &#123;</span><br><span class="line">submit_and_realloc:</span><br><span class="line">                        submit_bio(READ, bio);</span><br><span class="line">                        bio = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第六步，如果bio是空，则创建一个bio，然后指定的f2fs_read_end_io进行读取</span></span><br><span class="line">                <span class="keyword">if</span> (bio == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_ctx</span> *<span class="title">ctx</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (f2fs_encrypted_inode(inode) &amp;&amp;</span><br><span class="line">                                        S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"></span><br><span class="line">                                ctx = fscrypt_get_ctx(inode, GFP_NOFS);</span><br><span class="line">                                <span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">                                        <span class="keyword">goto</span> set_error_page;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">/* wait the page to be moved by cleaning */</span></span><br><span class="line">                                f2fs_wait_on_encrypted_page_writeback(</span><br><span class="line">                                                F2FS_I_SB(inode), block_nr);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bio = bio_alloc(GFP_KERNEL,</span><br><span class="line">                                <span class="type">min_t</span>(<span class="type">int</span>, nr_pages, BIO_MAX_PAGES)); <span class="comment">// 创建bio</span></span><br><span class="line">                        <span class="keyword">if</span> (!bio) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (ctx)</span><br><span class="line">                                        fscrypt_release_ctx(ctx);</span><br><span class="line">                                <span class="keyword">goto</span> set_error_page;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bio-&gt;bi_bdev = bdev;</span><br><span class="line">                        bio-&gt;bi_iter.bi_sector = SECTOR_FROM_BLOCK(block_nr); <span class="comment">// 设定bio的sector地址</span></span><br><span class="line">                        bio-&gt;bi_end_io = f2fs_read_end_io;</span><br><span class="line">                        bio-&gt;bi_private = ctx;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环第七步，将page加入到bio中，等待第五步满了之后发送到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (bio_add_page(bio, page, blocksize, <span class="number">0</span>) &lt; blocksize)</span><br><span class="line">                        <span class="keyword">goto</span> submit_and_realloc;</span><br><span class="line"></span><br><span class="line">set_error_page:</span><br><span class="line">                SetPageError(page);</span><br><span class="line">                zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">                unlock_page(page);</span><br><span class="line">                <span class="keyword">goto</span> next_page;</span><br><span class="line">confused: <span class="comment">// 特殊情况进行submit bio</span></span><br><span class="line">                <span class="keyword">if</span> (bio) &#123;</span><br><span class="line">                        submit_bio(READ, bio);</span><br><span class="line">                        bio = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unlock_page(page);</span><br><span class="line">next_page:</span><br><span class="line">                <span class="keyword">if</span> (pages)</span><br><span class="line">                        put_page(page);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        BUG_ON(pages &amp;&amp; !list_empty(pages));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还有bio没有处理，例如读取的页遍历完以后，还没有达到第五步要求的bio的最大保存页数，就会在这里提交bio到磁盘读取</span></span><br><span class="line">        <span class="keyword">if</span> (bio)</span><br><span class="line">                submit_bio(READ, bio);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="garbage-collection">garbage collection</h3><p>F2FS 的 GC 入口在 <code>f2fs_gc()</code>。这个函数的 caller 有 2 个：</p><ul><li>一个是前面接触到的 <code>f2fs_balance_fs()</code></li><li>另一个是后台 <code>kthread</code> 执行的 <code>gc_thread_func()</code></li></ul><h4 id="Background-GC">Background GC</h4><p>f2fs_fill_super() 初始化执行了 start_gc_thread()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start_gc_thread</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 一个 kthread 封装类</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_gc_kthread</span> *<span class="title">gc_th</span>;</span></span><br><span class="line"></span><br><span class="line">        gc_th = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_gc_kthread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!gc_th)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        sbi-&gt;gc_thread = gc_th;</span><br><span class="line">        init_waitqueue_head(&amp;sbi-&gt;gc_thread-&gt;gc_wait_queue_head);</span><br><span class="line">        <span class="comment">// kthread 的任务是 gc_thread_func</span></span><br><span class="line">        sbi-&gt;gc_thread-&gt;f2fs_gc_task = kthread_run(gc_thread_func, sbi,</span><br><span class="line">                                GC_THREAD_NAME);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(gc_th-&gt;f2fs_gc_task)) &#123;</span><br><span class="line">                kfree(gc_th);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_thread_func</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> data;</span><br><span class="line">        <span class="type">wait_queue_head_t</span> *wq = &amp;sbi-&gt;gc_thread-&gt;gc_wait_queue_head;</span><br><span class="line">        <span class="type">long</span> wait_ms;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC_THREAD_MIN_SLEEP_TIME: 10s</span></span><br><span class="line">        wait_ms = GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// freezer 特性，如果系统处于休眠则等待</span></span><br><span class="line">                <span class="keyword">if</span> (try_to_freeze())</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 等待 wait_ms 时间，这个数值会在后续动态调节</span></span><br><span class="line">                        wait_event_interruptible_timeout(*wq,</span><br><span class="line">                                                kthread_should_stop(),</span><br><span class="line">                                                msecs_to_jiffies(wait_ms));</span><br><span class="line">                <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有足够 free section，会强制进入主流程 f2fs_gc()</span></span><br><span class="line">                <span class="comment">// 否则什么都不干</span></span><br><span class="line">                f2fs_balance_fs(sbi);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!test_opt(sbi, BG_GC))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * [GC triggering condition]</span></span><br><span class="line"><span class="comment">                 * 0. GC is not conducted currently.</span></span><br><span class="line"><span class="comment">                 * 1. There are enough dirty segments.</span></span><br><span class="line"><span class="comment">                 * 2. IO subsystem is idle by checking the # of writeback pages.</span></span><br><span class="line"><span class="comment">                 * 3. IO subsystem is idle by checking the # of requests in</span></span><br><span class="line"><span class="comment">                 *    bdev&#x27;s request list.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Note) We have to avoid triggering GCs too much frequently.</span></span><br><span class="line"><span class="comment">                 * Because it is possible that some segments can be</span></span><br><span class="line"><span class="comment">                 * invalidated soon after by user update or deletion.</span></span><br><span class="line"><span class="comment">                 * So, I&#x27;d like to wait some time to collect dirty segments.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!mutex_trylock(&amp;sbi-&gt;gc_mutex))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!is_idle(sbi)) &#123;</span><br><span class="line">                        wait_ms = increase_sleep_time(wait_ms);</span><br><span class="line">                        mutex_unlock(&amp;sbi-&gt;gc_mutex);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// invalid（没写过的 block）超 40%，就会缩减等待时间，提高后台频率</span></span><br><span class="line">                <span class="keyword">if</span> (has_enough_invalid_blocks(sbi))</span><br><span class="line">                        <span class="comment">// 减 10s，但不超过 10s 阈值</span></span><br><span class="line">                        wait_ms = decrease_sleep_time(wait_ms);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 加 10s，但不超过 30s 阈值</span></span><br><span class="line">                        wait_ms = increase_sleep_time(wait_ms);</span><br><span class="line"></span><br><span class="line">                sbi-&gt;bg_gc++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入 GC 主流程</span></span><br><span class="line">                <span class="keyword">if</span> (f2fs_gc(sbi) == GC_NONE)</span><br><span class="line">                        <span class="comment">// 作者的意思应该是没有发生 GC，可能的情况是：</span></span><br><span class="line">                        <span class="comment">// - super block 尚未完成初始化</span></span><br><span class="line">                        <span class="comment">// - victim 挑选失败（比如每一个 segno 都成本过高）</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// GC_THREAD_NOGC_SLEEP_TIME: 10s</span></span><br><span class="line">                        wait_ms = GC_THREAD_NOGC_SLEEP_TIME;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (wait_ms == GC_THREAD_NOGC_SLEEP_TIME)</span><br><span class="line">                        <span class="comment">// 如果上一次走了 NOGC 的情况，这次强制降低频率</span></span><br><span class="line">                        <span class="comment">// GC_THREAD_MAX_SLEEP_TIME: 30s</span></span><br><span class="line">                        wait_ms = GC_THREAD_MAX_SLEEP_TIME;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (!kthread_should_stop());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">has_enough_invalid_blocks</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 没有写过的 block 数目</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">        <span class="comment">// LFS 写操作下，旧 block 不算入 written</span></span><br><span class="line">        <span class="comment">// 详见 update_sit_entry() 的 written_valid_blocks 更新</span></span><br><span class="line">        <span class="type">block_t</span> invalid_user_blocks = sbi-&gt;user_block_count -</span><br><span class="line">                                        written_block_count(sbi);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Background GC is triggered with the following condition.</span></span><br><span class="line"><span class="comment">         * 1. There are a number of invalid blocks.</span></span><br><span class="line"><span class="comment">         * 2. There is not enough free space.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// invalid user 超过了 40% 总数，free user 小于 40% 总数</span></span><br><span class="line">        <span class="keyword">if</span> (invalid_user_blocks &gt; limit_invalid_user_blocks(sbi) &amp;&amp;</span><br><span class="line">                        free_user_blocks(sbi) &lt; limit_free_user_blocks(sbi))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="title function_">decrease_sleep_time</span><span class="params">(<span class="type">long</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 减去 10s，但不得低于 10s</span></span><br><span class="line">        wait -= GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">if</span> (wait &lt;= GC_THREAD_MIN_SLEEP_TIME)</span><br><span class="line">                wait = GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">return</span> wait;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> <span class="title function_">increase_sleep_time</span><span class="params">(<span class="type">long</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 加上 10s，但不得高于 30s</span></span><br><span class="line">        wait += GC_THREAD_MIN_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">if</span> (wait &gt; GC_THREAD_MAX_SLEEP_TIME)</span><br><span class="line">                wait = GC_THREAD_MAX_SLEEP_TIME;</span><br><span class="line">        <span class="keyword">return</span> wait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主流程">主流程</h4><p>不管前台 GC 还是后台 GC，都会进入到统一的 GC 接口 f2fs_gc()。后台 GC 的情况在前面已经说明了；而前台 GC 可能会通过 f2fs_balance_fs() 在多个流程插入，只要 free section 低于预期，就会进入主流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_gc</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ilist</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno, i;</span><br><span class="line">        <span class="type">int</span> gc_type = BG_GC;</span><br><span class="line">        <span class="type">int</span> gc_status = GC_NONE;</span><br><span class="line"></span><br><span class="line">        INIT_LIST_HEAD(&amp;ilist);</span><br><span class="line">gc_more:</span><br><span class="line">        <span class="comment">// 不清楚 MS_ACTIVE 具体含义</span></span><br><span class="line">        <span class="comment">// 但是在 mount 过程中 VFS 会加上这个标记</span></span><br><span class="line">        <span class="keyword">if</span> (!(sbi-&gt;sb-&gt;s_flags &amp; MS_ACTIVE))</span><br><span class="line">                <span class="keyword">goto</span> stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有足够的 free section</span></span><br><span class="line">        <span class="comment">// 那就改为 FG GC，默认是 BG GC</span></span><br><span class="line">        <span class="keyword">if</span> (has_not_enough_free_secs(sbi))</span><br><span class="line">                gc_type = FG_GC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// victim selection 过程，完成结果传入 segno</span></span><br><span class="line">        <span class="keyword">if</span> (!__get_victim(sbi, &amp;segno, gc_type, NO_CHECK_TYPE))</span><br><span class="line">                <span class="keyword">goto</span> stop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 论文提到，GC 执行是以 section 为单位的</span></span><br><span class="line">        <span class="comment">// 以拿到的 segment 为起始遍历 section 长度</span></span><br><span class="line">        <span class="comment">// 一般就一次，因为 1 segment = 1 section</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sbi-&gt;segs_per_sec; i++) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * do_garbage_collect will give us three gc_status:</span></span><br><span class="line"><span class="comment">                 * GC_ERROR, GC_DONE, and GC_BLOCKED.</span></span><br><span class="line"><span class="comment">                 * If GC is finished uncleanly, we have to return</span></span><br><span class="line"><span class="comment">                 * the victim to dirty segment list.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 核心函数</span></span><br><span class="line">                gc_status = do_garbage_collect(sbi, segno + i, &amp;ilist, gc_type);</span><br><span class="line">                <span class="keyword">if</span> (gc_status != GC_DONE)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (has_not_enough_free_secs(sbi)) &#123;</span><br><span class="line">                write_checkpoint(sbi, (gc_status == GC_BLOCKED), <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (has_not_enough_free_secs(sbi))</span><br><span class="line">                        <span class="keyword">goto</span> gc_more;</span><br><span class="line">        &#125;</span><br><span class="line">stop:</span><br><span class="line">        mutex_unlock(&amp;sbi-&gt;gc_mutex);</span><br><span class="line"></span><br><span class="line">        put_gc_inode(&amp;ilist);</span><br><span class="line">        <span class="keyword">return</span> gc_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 GC 真正执行前，需要挑选 victim</p><h4 id="Victim-selection">Victim selection</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过注册接口的方式，可以自己实现垃圾回收的选择算法</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __get_victim(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> *victim,</span><br><span class="line">                                                <span class="type">int</span> gc_type, <span class="type">int</span> type)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        mutex_lock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        ret = DIRTY_I(sbi)-&gt;v_ops-&gt;get_victim(sbi, victim, gc_type, type, LFS);</span><br><span class="line">        mutex_unlock(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* victim selection function for cleaning and SSR */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">victim_selection</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*get_victim)(<span class="keyword">struct</span> f2fs_sb_info *, <span class="type">unsigned</span> <span class="type">int</span> *,</span><br><span class="line">                                                        <span class="type">int</span>, <span class="type">int</span>, <span class="type">char</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">victim_selection</span> <span class="title">default_v_ops</span> =</span> &#123;</span><br><span class="line">        .get_victim = get_victim_by_default,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function is called from two pathes.</span></span><br><span class="line"><span class="comment"> * One is garbage collection and the other is SSR segment selection.</span></span><br><span class="line"><span class="comment"> * When it is called during GC, it just gets a victim segment</span></span><br><span class="line"><span class="comment"> * and it does not remove it from dirty seglist.</span></span><br><span class="line"><span class="comment"> * When it is called from SSR segment selection, it finds a segment</span></span><br><span class="line"><span class="comment"> * which has minimum valid blocks and removes it from dirty seglist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_victim_by_default</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">int</span> *result, <span class="type">int</span> gc_type, <span class="type">int</span> type, <span class="type">char</span> alloc_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">victim_sel_policy</span> <span class="title">p</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno;</span><br><span class="line">        <span class="type">int</span> nsearched = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果空间不足，这里固定为 LFS</span></span><br><span class="line">        p.alloc_mode = alloc_mode;</span><br><span class="line">        <span class="comment">// 如果空间不足，这里确定：</span></span><br><span class="line">        <span class="comment">// - gc_mode 为 greedy</span></span><br><span class="line">        <span class="comment">// - ofs_unit 为 1</span></span><br><span class="line">        select_policy(sbi, gc_type, type, &amp;p);</span><br><span class="line"></span><br><span class="line">        p.min_segno = NULL_SEGNO;</span><br><span class="line">        p.min_cost = get_max_cost(sbi, &amp;p);</span><br><span class="line"></span><br><span class="line">        mutex_lock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.alloc_mode == LFS &amp;&amp; gc_type == FG_GC) &#123;</span><br><span class="line">                <span class="comment">// 先尝试获取 BG_GC 获得的 victim</span></span><br><span class="line">                <span class="comment">// min_segno 应该是 min_cost 对应的 segment</span></span><br><span class="line">                <span class="comment">// 毕竟 BG 的算法是 min_cost 的</span></span><br><span class="line">                p.min_segno = check_bg_victims(sbi);</span><br><span class="line">                <span class="keyword">if</span> (p.min_segno != NULL_SEGNO)</span><br><span class="line">                        <span class="comment">// 如果有就立刻结束</span></span><br><span class="line">                        <span class="keyword">goto</span> got_it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则再按照算法查找</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> cost;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// p.offset 指的是 last scanned bitmap offset，因此从这里开始</span></span><br><span class="line">                <span class="comment">// 从 dirty segmap 选择一个 dirty segment</span></span><br><span class="line">                segno = find_next_bit(p.dirty_segmap,</span><br><span class="line">                                                TOTAL_SEGS(sbi), p.offset);</span><br><span class="line">                <span class="comment">// 没找到 dirty segment</span></span><br><span class="line">                <span class="comment">// 循环会跳出</span></span><br><span class="line">                <span class="keyword">if</span> (segno &gt;= TOTAL_SEGS(sbi)) &#123;</span><br><span class="line">                        <span class="comment">// last_victim：一个大小为 2 的数组，按照 gc_mode 区分</span></span><br><span class="line">                        <span class="comment">// 此时先清空？不太明白，感觉是指完整扫描过一遍了</span></span><br><span class="line">                        <span class="keyword">if</span> (sbi-&gt;last_victim[p.gc_mode]) &#123;</span><br><span class="line">                                sbi-&gt;last_victim[p.gc_mode] = <span class="number">0</span>;</span><br><span class="line">                                p.offset = <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个 find_next_bit 的开始地址</span></span><br><span class="line">                p.offset = ((segno / p.ofs_unit) * p.ofs_unit) + p.ofs_unit;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> victim_segmap 默认为空，见 init_victim_segmap()</span></span><br><span class="line">                <span class="comment">// 但是挑选的 dirty segment 这里已经被 victim segmap 标记</span></span><br><span class="line">                <span class="comment">// 更新时机见 got_it 部分</span></span><br><span class="line">                <span class="keyword">if</span> (test_bit(segno, dirty_i-&gt;victim_segmap[FG_GC]))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (gc_type == BG_GC &amp;&amp;</span><br><span class="line">                                test_bit(segno, dirty_i-&gt;victim_segmap[BG_GC]))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 不处理 curseg 指向的起始 section</span></span><br><span class="line">                <span class="keyword">if</span> (IS_CURSEC(sbi, GET_SECNO(sbi, segno)))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 见下方具体流程</span></span><br><span class="line">                <span class="comment">// 在当前的上下文中，就是获取 valid block 数目作为成本</span></span><br><span class="line">                cost = get_gc_cost(sbi, segno, &amp;p);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果找到真·min_cost，那就更新对应的 min_segno</span></span><br><span class="line">                <span class="keyword">if</span> (p.min_cost &gt; cost) &#123;</span><br><span class="line">                        p.min_segno = segno;</span><br><span class="line">                        p.min_cost = cost;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果成本太大，不能选</span></span><br><span class="line">                <span class="comment">// 需要下一次循环用新的 p.offset 再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (cost == get_max_cost(sbi, &amp;p))</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 迭代是有限次数的，MAX_VICTIM_SEARCH = 20</span></span><br><span class="line">                <span class="keyword">if</span> (nsearched++ &gt;= MAX_VICTIM_SEARCH) &#123;</span><br><span class="line">                        <span class="comment">// 最后一次找到的 segno，不管是否 min 都记下了</span></span><br><span class="line">                        <span class="comment">// 这有什么用呢？我认为是加速 GC，因为在 select_policy 中，</span></span><br><span class="line">                        <span class="comment">// 可以看到 GC 扫描开始的 p.offset 就是使用 last_victim</span></span><br><span class="line">                        sbi-&gt;last_victim[p.gc_mode] = segno;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">got_it:</span><br><span class="line">        <span class="keyword">if</span> (p.min_segno != NULL_SEGNO) &#123;</span><br><span class="line">                <span class="comment">// 从这里可以看出最终目标就是求出 p.min_segno</span></span><br><span class="line">                <span class="comment">// 这里一直有除后再乘上的操作是因为作者假定 section 和 segment 不是统一单位</span></span><br><span class="line">                *result = (p.min_segno / p.ofs_unit) * p.ofs_unit;</span><br><span class="line">                <span class="keyword">if</span> (p.alloc_mode == LFS) &#123;</span><br><span class="line">                        <span class="type">int</span> i;</span><br><span class="line">                        <span class="comment">// 标记对应的 victim segmap</span></span><br><span class="line">                        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p.ofs_unit; i++)</span><br><span class="line">                                set_bit(*result + i,</span><br><span class="line">                                        dirty_i-&gt;victim_segmap[gc_type]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (p.min_segno == NULL_SEGNO) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">select_policy</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">int</span> gc_type,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> type, <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LFS 走这里</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;alloc_mode) &#123;</span><br><span class="line">                <span class="comment">// 在当前的流程中，p 已经确定是 LFS，因此是 GREEDY</span></span><br><span class="line">                p-&gt;gc_mode = GC_GREEDY;</span><br><span class="line">                p-&gt;dirty_segmap = dirty_i-&gt;dirty_segmap[type];</span><br><span class="line">                p-&gt;ofs_unit = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 赋予gc算法类型，默认有两种算法，即greedy算法(GC_GREEDY)，以及cost-benefit算法(GC_CB)</span></span><br><span class="line">                p-&gt;gc_mode = select_gc_type(gc_type);</span><br><span class="line">                <span class="comment">// 即脏的segment所对应的segmap，它的作用是标记了这个segmen里面的block有效无效信息</span></span><br><span class="line">                p-&gt;dirty_segmap = dirty_i-&gt;dirty_segmap[DIRTY];</span><br><span class="line">                p-&gt;ofs_unit = sbi-&gt;segs_per_sec;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;offset = sbi-&gt;last_victim[p-&gt;gc_mode]; <span class="comment">// 上一个被回收的segment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_max_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;gc_mode == GC_GREEDY)</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocks_per_seg) * p-&gt;ofs_unit;</span><br><span class="line">        <span class="comment">// CB 是 Cost-Benefit 的意思</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;gc_mode == GC_CB)</span><br><span class="line">                <span class="keyword">return</span> UINT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/* No other gc_mode */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">check_bg_victims</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> segno;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the gc_type is FG_GC, we can select victim segments</span></span><br><span class="line"><span class="comment">         * selected by background GC before.</span></span><br><span class="line"><span class="comment">         * Those segments guarantee they have small valid blocks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        segno = find_next_bit(dirty_i-&gt;victim_segmap[BG_GC],</span><br><span class="line">                                                TOTAL_SEGS(sbi), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (segno &lt; TOTAL_SEGS(sbi)) &#123;</span><br><span class="line">                clear_bit(segno, dirty_i-&gt;victim_segmap[BG_GC]);</span><br><span class="line">                <span class="keyword">return</span> segno;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NULL_SEGNO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_gc_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno,</span></span><br><span class="line"><span class="params">                                        <span class="keyword">struct</span> victim_sel_policy *p)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;alloc_mode == SSR)</span><br><span class="line">                <span class="keyword">return</span> get_seg_entry(sbi, segno)-&gt;ckpt_valid_blocks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* alloc_mode == LFS */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;gc_mode == GC_GREEDY)</span><br><span class="line">                <span class="comment">// 从 select_policy() 分析得出目前流程会走到这里</span></span><br><span class="line">                <span class="comment">// 查找 valid block 数目最少的 segno，避免迁移成本</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span> 这里不用取最小，这个工作在 get_victim_by_default() 完成</span></span><br><span class="line">                <span class="comment">// 实现上就是得到 sentry 的 valid_blocks 字段（非常直接）</span></span><br><span class="line">                <span class="keyword">return</span> get_valid_blocks(sbi, segno, sbi-&gt;segs_per_sec);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 最优成本算法，考虑老化</span></span><br><span class="line">                <span class="keyword">return</span> get_cb_cost(sbi, segno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">get_cb_cost</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> secno = GET_SECNO(sbi, segno);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> start = secno * sbi-&gt;segs_per_sec;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mtime = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vblocks;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> age = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> u;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累计 mtime</span></span><br><span class="line">        <span class="comment">// 这里 mtime 是每个 segment 加起来的</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sbi-&gt;segs_per_sec; i++)</span><br><span class="line">                mtime += get_seg_entry(sbi, start + i)-&gt;mtime;</span><br><span class="line">        vblocks = get_valid_blocks(sbi, segno, sbi-&gt;segs_per_sec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换算 mtime 为 segment 平均水平</span></span><br><span class="line">        mtime = div_u64(mtime, sbi-&gt;segs_per_sec);</span><br><span class="line">        vblocks = div_u64(vblocks, sbi-&gt;segs_per_sec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数 1：u，块利用率（util%）的意思</span></span><br><span class="line">        <span class="comment">// u = vblock * 100 / 512</span></span><br><span class="line">        <span class="comment">//   = vblock / 512 * 100 (vblock &lt;= 512)</span></span><br><span class="line">        <span class="comment">//   &lt;= 100</span></span><br><span class="line">        u = (vblocks * <span class="number">100</span>) &gt;&gt; sbi-&gt;log_blocks_per_seg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle if the system time is changed by user */</span></span><br><span class="line">        <span class="comment">// min 和 max 指的是这个 segment 中的最大最小修改时间</span></span><br><span class="line">        <span class="comment">// 话说为啥平均水平会超出最值呢？好神奇哦</span></span><br><span class="line">        <span class="keyword">if</span> (mtime &lt; sit_i-&gt;min_mtime)</span><br><span class="line">                sit_i-&gt;min_mtime = mtime;</span><br><span class="line">        <span class="keyword">if</span> (mtime &gt; sit_i-&gt;max_mtime)</span><br><span class="line">                sit_i-&gt;max_mtime = mtime;</span><br><span class="line">        <span class="comment">// 避免除以 0</span></span><br><span class="line">        <span class="keyword">if</span> (sit_i-&gt;max_mtime != sit_i-&gt;min_mtime)</span><br><span class="line">                <span class="comment">// 参数 2：age，一个 segment 的年纪</span></span><br><span class="line">                <span class="comment">// age = 100 - 100*(avg - min)/(max - min)</span></span><br><span class="line">                <span class="comment">// 这个估值方式有点疑问，为什么是单调时钟而不考虑 sbi 设墙上时钟？</span></span><br><span class="line">                <span class="comment">// 总之是这个算法吧，很久没任何改动就大概是年纪大（avg≈min，age≈100）</span></span><br><span class="line">                age = <span class="number">100</span> - div64_u64(<span class="number">100</span> * (mtime - sit_i-&gt;min_mtime),</span><br><span class="line">                                sit_i-&gt;max_mtime - sit_i-&gt;min_mtime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用率部分为 (100-u)/(100+u)，u 范围 [0,100] 的结果是单调递减的</span></span><br><span class="line">        <span class="comment">// 考虑负数的优先级反转后（且要尽可能小的数值），总结：</span></span><br><span class="line">        <span class="comment">// - 年纪越大，越容易毕业</span></span><br><span class="line">        <span class="comment">// - 利用率越低，越容易毕业</span></span><br><span class="line">        <span class="keyword">return</span> UINT_MAX - ((<span class="number">100</span> * (<span class="number">100</span> - u) * age) / (<span class="number">100</span> + u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GC-procedure">GC procedure</h4><p>处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mi>s</mi><mi>e</mi><mi>g</mi><mi>n</mi><mi>o</mi><mo separator="true">,</mo><mtext>  </mtext><mi>s</mi><mi>e</mi><mi>g</mi><mi>n</mi><mi>o</mi><mo>+</mo><mi>s</mi><mi>e</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left[segno,\; segno+segments\_per\_section\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">o</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">se</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">sec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>编号范围的 segment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_garbage_collect</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">unsigned</span> <span class="type">int</span> segno,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> list_head *ilist, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">sum_page</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> *<span class="title">sum</span>;</span></span><br><span class="line">        <span class="type">int</span> ret = GC_DONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read segment summary of victim */</span></span><br><span class="line">        <span class="comment">// 获取关联的 summary</span></span><br><span class="line">        sum_page = get_sum_page(sbi, segno);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(sum_page))</span><br><span class="line">                <span class="keyword">return</span> GC_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CP needs to lock sum_page. In this time, we don&#x27;t need</span></span><br><span class="line"><span class="comment">         * to lock this page, because this summary page is not gone anywhere.</span></span><br><span class="line"><span class="comment">         * Also, this page is not gonna be updated before GC is done.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        unlock_page(sum_page);</span><br><span class="line">        sum = page_address(sum_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 区分类型的 GC 操作</span></span><br><span class="line">        <span class="keyword">switch</span> (GET_SUM_TYPE((&amp;sum-&gt;footer))) &#123;</span><br><span class="line">        <span class="keyword">case</span> SUM_TYPE_NODE:</span><br><span class="line">                ret = gc_node_segment(sbi, sum-&gt;entries, segno, gc_type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SUM_TYPE_DATA:</span><br><span class="line">                ret = gc_data_segment(sbi, sum-&gt;entries, ilist, segno, gc_type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stat_inc_seg_count(sbi, GET_SUM_TYPE((&amp;sum-&gt;footer)));</span><br><span class="line">        stat_inc_call_count(sbi-&gt;stat_info);</span><br><span class="line"></span><br><span class="line">        f2fs_put_page(sum_page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function tries to get parent node of victim data block, and identifies</span></span><br><span class="line"><span class="comment"> * data block validity. If the block is valid, copy that with cold status and</span></span><br><span class="line"><span class="comment"> * modify parent node.</span></span><br><span class="line"><span class="comment"> * If the parent node is not valid or the data block address is different,</span></span><br><span class="line"><span class="comment"> * the victim data block is ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_data_segment</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> f2fs_summary *sum,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *ilist, <span class="type">unsigned</span> <span class="type">int</span> segno, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> sbi-&gt;sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> *<span class="title">entry</span>;</span></span><br><span class="line">        <span class="type">block_t</span> start_addr;</span><br><span class="line">        <span class="type">int</span> err, off;</span><br><span class="line">        <span class="type">int</span> phase = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// segno 起始 block 转为 block_t 单位</span></span><br><span class="line">        start_addr = START_BLOCK(sbi, segno);</span><br><span class="line"></span><br><span class="line">next_step:</span><br><span class="line">        entry = sum;</span><br><span class="line">        <span class="comment">// 遍历 segment，off 是 block 个数偏移量</span></span><br><span class="line">        <span class="comment">// 完整 for 一遍后才会 phase 递增，再执行 for</span></span><br><span class="line">        <span class="keyword">for</span> (off = <span class="number">0</span>; off &lt; sbi-&gt;blocks_per_seg; off++, entry++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">data_page</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">node_info</span> <span class="title">dni</span>;</span> <span class="comment">/* dnode info for the data */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> ofs_in_node, nofs;</span><br><span class="line">                <span class="type">block_t</span> start_bidx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * It makes sure that free segments are able to write</span></span><br><span class="line"><span class="comment">                 * all the dirty node pages before CP after this CP.</span></span><br><span class="line"><span class="comment">                 * So let&#x27;s check the space of dirty node pages.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (should_do_checkpoint(sbi)) &#123;</span><br><span class="line">                        mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">                        block_operations(sbi);</span><br><span class="line">                        err = GC_BLOCKED;</span><br><span class="line">                        <span class="keyword">goto</span> stop;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 segno 获取 sentry</span></span><br><span class="line">                <span class="comment">// 再根据 off 进行 sentry-&gt;cur_valid_map 的 testbit</span></span><br><span class="line">                <span class="comment">// 正常返回 GC_OK (bit:1)</span></span><br><span class="line">                <span class="comment">// <span class="doctag">NOTE:</span></span></span><br><span class="line">                <span class="comment">// bitmap 更新时机在前面 SIT update 章节中的 update_sit_entry()</span></span><br><span class="line">                <span class="comment">// 就是说 write page 时一般都置旧页/块为 1</span></span><br><span class="line">                err = check_valid_map(sbi, segno, off);</span><br><span class="line">                <span class="keyword">if</span> (err == GC_NEXT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 阶段 0，预读 node page</span></span><br><span class="line">                        <span class="comment">//（nid 通过 block 寻址获得，赋值 callee 见 set_summary()）</span></span><br><span class="line">                        <span class="comment">// <span class="doctag">NOTE:</span> 这些预读是为下一个 phase 确保 page 已在内存中</span></span><br><span class="line">                        ra_node_page(sbi, le32_to_cpu(entry-&gt;nid));</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Get an inode by ino with checking validity */</span></span><br><span class="line">                <span class="comment">// 获取 dni，可进一步获取 inode</span></span><br><span class="line">                err = check_dnode(sbi, entry, &amp;dni, start_addr + off, &amp;nofs);</span><br><span class="line">                <span class="keyword">if</span> (err == GC_NEXT)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 阶段 1，预读 inode page</span></span><br><span class="line">                        ra_node_page(sbi, dni.ino);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// start_bidx 含义：start block index indicating the given node offset</span></span><br><span class="line">                start_bidx = start_bidx_of_node(nofs);</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> fill_node_footer()</span></span><br><span class="line">                ofs_in_node = le16_to_cpu(entry-&gt;ofs_in_node);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (phase == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获得 inode 实例</span></span><br><span class="line">                        inode = f2fs_iget_nowait(sb, dni.ino);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 以 start_bidx + ofs_in_node 为 page index 定位到 data page</span></span><br><span class="line">                        data_page = find_data_page(inode,</span><br><span class="line">                                        start_bidx + ofs_in_node);</span><br><span class="line">                        <span class="keyword">if</span> (IS_ERR(data_page))</span><br><span class="line">                                <span class="keyword">goto</span> next_iput;</span><br><span class="line"></span><br><span class="line">                        f2fs_put_page(data_page, <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// inode 加入到 gc list（ilist，是一个栈上的链表）</span></span><br><span class="line">                        add_gc_inode(inode, ilist);</span><br><span class="line">                <span class="comment">// 这里 phase == 3</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 遍历找到 ino</span></span><br><span class="line">                        inode = find_gc_inode(dni.ino, ilist);</span><br><span class="line">                        <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">                                data_page = get_lock_data_page(inode,</span><br><span class="line">                                                start_bidx + ofs_in_node);</span><br><span class="line">                                <span class="keyword">if</span> (IS_ERR(data_page))</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                move_data_page(inode, data_page, gc_type);</span><br><span class="line">                                stat_inc_data_blk_count(sbi, <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">next_iput:</span><br><span class="line">                iput(inode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (++phase &lt; <span class="number">4</span>)</span><br><span class="line">                <span class="keyword">goto</span> next_step;</span><br><span class="line">        err = GC_DONE;</span><br><span class="line">stop:</span><br><span class="line">        <span class="keyword">if</span> (gc_type == FG_GC)</span><br><span class="line">                f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_gc_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> list_head *ilist)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">        <span class="comment">// inode_entry 是个&lt;list_head*, inode*&gt;二元组</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode_entry</span> *<span class="title">new_ie</span>, *<span class="title">ie</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免重复加入</span></span><br><span class="line">        list_for_each(this, ilist) &#123;</span><br><span class="line">                ie = list_entry(this, <span class="keyword">struct</span> inode_entry, <span class="built_in">list</span>);</span><br><span class="line">                <span class="keyword">if</span> (ie-&gt;inode == inode) &#123;</span><br><span class="line">                        iput(inode);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">repeat:</span><br><span class="line">        new_ie = kmem_cache_alloc(winode_slab, GFP_NOFS);</span><br><span class="line">        <span class="keyword">if</span> (!new_ie) &#123;</span><br><span class="line">                cond_resched();</span><br><span class="line">                <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        new_ie-&gt;inode = inode;</span><br><span class="line">        list_add_tail(&amp;new_ie-&gt;<span class="built_in">list</span>, ilist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">find_gc_inode</span><span class="params">(<span class="type">nid_t</span> ino, <span class="keyword">struct</span> list_head *ilist)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">this</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode_entry</span> *<span class="title">ie</span>;</span></span><br><span class="line"></span><br><span class="line">        list_for_each(this, ilist) &#123;</span><br><span class="line">                ie = list_entry(this, <span class="keyword">struct</span> inode_entry, <span class="built_in">list</span>);</span><br><span class="line">                <span class="keyword">if</span> (ie-&gt;inode-&gt;i_ino == ino)</span><br><span class="line">                        <span class="keyword">return</span> ie-&gt;inode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">move_data_page</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> page *page, <span class="type">int</span> gc_type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;mapping != inode-&gt;i_mapping)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inode != page-&gt;mapping-&gt;host)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageWriteback(page))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BG 的时候没有实际移动，而是设为 COLD</span></span><br><span class="line">        <span class="keyword">if</span> (gc_type == BG_GC) &#123;</span><br><span class="line">                set_page_dirty(page);</span><br><span class="line">                set_cold_data(page);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">struct</span> f2fs_sb_info *sbi = F2FS_SB(inode-&gt;i_sb);</span><br><span class="line">                mutex_lock_op(sbi, DATA_WRITE);</span><br><span class="line">                <span class="keyword">if</span> (clear_page_dirty_for_io(page) &amp;&amp;</span><br><span class="line">                        S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">                        dec_page_count(sbi, F2FS_DIRTY_DENTS);</span><br><span class="line">                        inode_dec_dirty_dents(inode);</span><br><span class="line">                &#125;</span><br><span class="line">                set_cold_data(page);</span><br><span class="line">                <span class="comment">// 写到新的位置，见 Write operation 章节</span></span><br><span class="line">                do_write_data_page(page);</span><br><span class="line">                mutex_unlock_op(sbi, DATA_WRITE);</span><br><span class="line">                clear_cold_data(page);</span><br><span class="line">        &#125;</span><br><span class="line">out:</span><br><span class="line">        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Recovery">Recovery</h3><p>触发 checkpoint 的主流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We guarantee that this checkpoint procedure should not fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_checkpoint</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">bool</span> blocked, <span class="type">bool</span> is_umount)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ckpt_ver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!blocked) &#123;</span><br><span class="line">                mutex_lock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">                <span class="comment">// 内部会 mutex lock 若干的锁</span></span><br><span class="line">                block_operations(sbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DATA 和 NODE 均是 main area block</span></span><br><span class="line">        <span class="comment">// META 则是 main area 之外的区域</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 然而 META 多是内存数据结构，刷下去也未必是最新的</span></span><br><span class="line">        f2fs_submit_bio(sbi, DATA, <span class="literal">true</span>);</span><br><span class="line">        f2fs_submit_bio(sbi, NODE, <span class="literal">true</span>);</span><br><span class="line">        f2fs_submit_bio(sbi, META, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * update checkpoint pack index</span></span><br><span class="line"><span class="comment">         * Increase the version number so that</span></span><br><span class="line"><span class="comment">         * SIT entries and seg summaries are written at correct place</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取 check point 版本号并且递增</span></span><br><span class="line">        ckpt_ver = le64_to_cpu(ckpt-&gt;checkpoint_ver);</span><br><span class="line">        ckpt-&gt;checkpoint_ver = cpu_to_le64(++ckpt_ver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write cached NAT/SIT entries to NAT/SIT area */</span></span><br><span class="line">        flush_nat_entries(sbi);</span><br><span class="line">        flush_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">        reset_victim_segmap(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlock all the fs_lock[] in do_checkpoint() */</span></span><br><span class="line">        do_checkpoint(sbi, is_umount);</span><br><span class="line"></span><br><span class="line">        unblock_operations(sbi);</span><br><span class="line">        mutex_unlock(&amp;sbi-&gt;cp_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_checkpoint</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">bool</span> is_umount)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">        <span class="type">nid_t</span> last_nid = <span class="number">0</span>;</span><br><span class="line">        <span class="type">block_t</span> start_blk;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cp_page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> data_sum_blocks, orphan_blocks;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> crc32 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">void</span> *kaddr;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Flush all the NAT/SIT pages */</span></span><br><span class="line">        <span class="keyword">while</span> (get_pages(sbi, F2FS_DIRTY_META))</span><br><span class="line">                sync_meta_pages(sbi, META, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出last_nid，后面写到check point的next_free_nid</span></span><br><span class="line">        next_free_nid(sbi, &amp;last_nid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * modify checkpoint</span></span><br><span class="line"><span class="comment">         * version number is already updated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// checkpoint_ver在NAT/SIT flush前已更新</span></span><br><span class="line">        ckpt-&gt;elapsed_time = cpu_to_le64(get_mtime(sbi));</span><br><span class="line">        ckpt-&gt;valid_block_count = cpu_to_le64(valid_user_blocks(sbi));</span><br><span class="line">        ckpt-&gt;free_segment_count = cpu_to_le32(free_segments(sbi));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                ckpt-&gt;cur_node_segno[i] =</span><br><span class="line">                        cpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_NODE));</span><br><span class="line">                ckpt-&gt;cur_node_blkoff[i] =</span><br><span class="line">                        cpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_NODE));</span><br><span class="line">                ckpt-&gt;alloc_type[i + CURSEG_HOT_NODE] =</span><br><span class="line">                                curseg_alloc_type(sbi, i + CURSEG_HOT_NODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                ckpt-&gt;cur_data_segno[i] =</span><br><span class="line">                        cpu_to_le32(curseg_segno(sbi, i + CURSEG_HOT_DATA));</span><br><span class="line">                ckpt-&gt;cur_data_blkoff[i] =</span><br><span class="line">                        cpu_to_le16(curseg_blkoff(sbi, i + CURSEG_HOT_DATA));</span><br><span class="line">                ckpt-&gt;alloc_type[i + CURSEG_HOT_DATA] =</span><br><span class="line">                                curseg_alloc_type(sbi, i + CURSEG_HOT_DATA);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ckpt-&gt;valid_node_count = cpu_to_le32(valid_node_count(sbi));</span><br><span class="line">        ckpt-&gt;valid_inode_count = cpu_to_le32(valid_inode_count(sbi));</span><br><span class="line">        ckpt-&gt;next_free_nid = cpu_to_le32(last_nid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 cp  + n data seg summary + orphan inode blocks */</span></span><br><span class="line">        <span class="comment">// 这是summary在CP area占用的page/block个数</span></span><br><span class="line">        data_sum_blocks = npages_for_summary_flush(sbi);</span><br><span class="line">        <span class="comment">// compact mode影响write_data_summaries()写入和restore_curseg_summaries()恢复</span></span><br><span class="line">        <span class="comment">// 1-2个page内可以搞定，就设为compact</span></span><br><span class="line">        <span class="keyword">if</span> (data_sum_blocks &lt; <span class="number">3</span>)</span><br><span class="line">                set_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                clear_ckpt_flags(ckpt, CP_COMPACT_SUM_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// orphan inode用于处理unlink/truncate时的一致性</span></span><br><span class="line">        <span class="comment">// 基本思路：</span></span><br><span class="line">        <span class="comment">// 1. 当需要删除/截断一个inode时，先把inode记录到orphan外存</span></span><br><span class="line">        <span class="comment">// 2. 操作成功后再从orphan移除</span></span><br><span class="line">        <span class="comment">// 3. 加载check point时会重做一遍仍在orphan里的操作</span></span><br><span class="line">        <span class="comment">// 这样在1-2操作完成前宕机仍保持一致性</span></span><br><span class="line">        orphan_blocks = (sbi-&gt;n_orphans + F2FS_ORPHANS_PER_BLOCK - <span class="number">1</span>)</span><br><span class="line">                                        / F2FS_ORPHANS_PER_BLOCK;</span><br><span class="line">        ckpt-&gt;cp_pack_start_sum = cpu_to_le32(<span class="number">1</span> + orphan_blocks);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_umount) &#123;</span><br><span class="line">                set_ckpt_flags(ckpt, CP_UMOUNT_FLAG);</span><br><span class="line">                ckpt-&gt;cp_pack_total_block_count = cpu_to_le32(<span class="number">2</span> +</span><br><span class="line">                        data_sum_blocks + orphan_blocks + NR_CURSEG_NODE_TYPE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clear_ckpt_flags(ckpt, CP_UMOUNT_FLAG);</span><br><span class="line">                ckpt-&gt;cp_pack_total_block_count = cpu_to_le32(<span class="number">2</span> +</span><br><span class="line">                        data_sum_blocks + orphan_blocks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;n_orphans)</span><br><span class="line">                set_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                clear_ckpt_flags(ckpt, CP_ORPHAN_PRESENT_FLAG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update SIT/NAT bitmap */</span></span><br><span class="line">        <span class="comment">// __bitmap_ptr指向ckpt中对应的bitmap</span></span><br><span class="line">        <span class="comment">// 这两个函数会把对应的sit_i-&gt;sit_bitmap和nm_i-&gt;nat_bitmap拷贝到ckpt</span></span><br><span class="line">        get_sit_bitmap(sbi, __bitmap_ptr(sbi, SIT_BITMAP));</span><br><span class="line">        get_nat_bitmap(sbi, __bitmap_ptr(sbi, NAT_BITMAP));</span><br><span class="line"></span><br><span class="line">        crc32 = f2fs_crc32(ckpt, le32_to_cpu(ckpt-&gt;checksum_offset));</span><br><span class="line">        *(__le32 *)((<span class="type">unsigned</span> <span class="type">char</span> *)ckpt +</span><br><span class="line">                                le32_to_cpu(ckpt-&gt;checksum_offset))</span><br><span class="line">                                = cpu_to_le32(crc32);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的开始地址是有讲究的</span></span><br><span class="line">        <span class="comment">// 前面讲过cp pack之间是交替存放的，间隔segment</span></span><br><span class="line">        start_blk = __start_cp_addr(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* write out checkpoint buffer at block 0 */</span></span><br><span class="line">        cp_page = grab_meta_page(sbi, start_blk++);</span><br><span class="line">        kaddr = page_address(cp_page);</span><br><span class="line">        <span class="comment">// 使用一个block存放ckpt</span></span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, ckpt, (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocksize));</span><br><span class="line">        set_page_dirty(cp_page);</span><br><span class="line">        f2fs_put_page(cp_page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用orphan_blocks数目的block存放orphan</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;n_orphans) &#123;</span><br><span class="line">                write_orphan_inodes(sbi, start_blk);</span><br><span class="line">                start_blk += orphan_blocks;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compact mode和normal mode的写入方式不一样</span></span><br><span class="line">        <span class="comment">// 使用data_sum_blocks数目的block存放data summary</span></span><br><span class="line">        write_data_summaries(sbi, start_blk);</span><br><span class="line">        start_blk += data_sum_blocks;</span><br><span class="line">        <span class="keyword">if</span> (is_umount) &#123;</span><br><span class="line">                <span class="comment">// umount的情况还写入node summary</span></span><br><span class="line">                write_node_summaries(sbi, start_blk);</span><br><span class="line">                <span class="comment">// 固定占坑3个block</span></span><br><span class="line">                start_blk += NR_CURSEG_NODE_TYPE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* writeout checkpoint block */</span></span><br><span class="line">        <span class="comment">// 再使用一个block存放ckpt，用于校验</span></span><br><span class="line">        cp_page = grab_meta_page(sbi, start_blk);</span><br><span class="line">        kaddr = page_address(cp_page);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, ckpt, (<span class="number">1</span> &lt;&lt; sbi-&gt;log_blocksize));</span><br><span class="line">        set_page_dirty(cp_page);</span><br><span class="line">        f2fs_put_page(cp_page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的就是善后处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* wait for previous submitted node/meta pages writeback */</span></span><br><span class="line">        <span class="keyword">while</span> (get_pages(sbi, F2FS_WRITEBACK))</span><br><span class="line">                congestion_wait(BLK_RW_ASYNC, HZ / <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        filemap_fdatawait_range(sbi-&gt;node_inode-&gt;i_mapping, <span class="number">0</span>, LONG_MAX);</span><br><span class="line">        filemap_fdatawait_range(sbi-&gt;meta_inode-&gt;i_mapping, <span class="number">0</span>, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update user_block_counts */</span></span><br><span class="line">        sbi-&gt;last_valid_block_count = sbi-&gt;total_valid_block_count;</span><br><span class="line">        sbi-&gt;alloc_valid_block_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Here, we only have one bio having CP pack */</span></span><br><span class="line">        <span class="keyword">if</span> (is_set_ckpt_flags(ckpt, CP_ERROR_FLAG))</span><br><span class="line">                <span class="comment">// 出事了就进入只读模式</span></span><br><span class="line">                sbi-&gt;sb-&gt;s_flags |= MS_RDONLY;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                sync_meta_pages(sbi, META_FLUSH, LONG_MAX);</span><br><span class="line"></span><br><span class="line">        clear_prefree_segments(sbi);</span><br><span class="line">        F2FS_RESET_SB_DIRT(sbi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Calculate the number of current summary pages for writing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">npages_for_summary_flush</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> total_size_bytes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// summary entry 数目</span></span><br><span class="line">        <span class="type">int</span> valid_sum_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, sum_space;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算curseg的sum block</span></span><br><span class="line">        <span class="keyword">for</span> (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sbi-&gt;ckpt-&gt;alloc_type[i] == SSR)</span><br><span class="line">                        valid_sum_count += sbi-&gt;blocks_per_seg;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 直接加上curseg-&gt;next_blkoff</span></span><br><span class="line">                        <span class="comment">// 一个seg内next_blkoff前的sum entry均有效</span></span><br><span class="line">                        valid_sum_count += curseg_blkoff(sbi, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么需要+1？</span></span><br><span class="line">        total_size_bytes = valid_sum_count * (SUMMARY_SIZE + <span class="number">1</span>)</span><br><span class="line">                        + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nat_journal) + <span class="number">2</span></span><br><span class="line">                        + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sit_journal) + <span class="number">2</span>;</span><br><span class="line">        sum_space = PAGE_CACHE_SIZE - SUM_FOOTER_SIZE;</span><br><span class="line">        <span class="comment">// 1个page内可以搞定</span></span><br><span class="line">        <span class="keyword">if</span> (total_size_bytes &lt; sum_space)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 2个page内可以搞定</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (total_size_bytes &lt; <span class="number">2</span> * sum_space)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 看后面分析，normal mode在3个page内必能搞定</span></span><br><span class="line">        <span class="comment">// 就是三种data type curseg，每种各写一个page</span></span><br><span class="line">        <span class="comment">// （sum_blk直接拷过去）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">block_t</span> __start_cp_addr(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">block_t</span> start_addr = le32_to_cpu(F2FS_RAW_SUPER(sbi)-&gt;cp_blkaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前面分析过 cp pack，交替使用，pack 之间间隔 segment 单位</span></span><br><span class="line">        <span class="keyword">if</span> (sbi-&gt;cur_cp_pack == <span class="number">2</span>)</span><br><span class="line">                start_addr += sbi-&gt;blocks_per_seg;</span><br><span class="line">        <span class="keyword">return</span> start_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_data_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">block_t</span> start_blk)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 区分 compact mode 还是 normal mode</span></span><br><span class="line">        <span class="keyword">if</span> (is_set_ckpt_flags(F2FS_CKPT(sbi), CP_COMPACT_SUM_FLAG))</span><br><span class="line">                write_compacted_summaries(sbi, start_blk);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                write_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_compacted_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">block_t</span> blkaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *kaddr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> *<span class="title">summary</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">seg_i</span>;</span></span><br><span class="line">        <span class="type">int</span> written_size = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里一开始传入 blkaddr 位于 CP area</span></span><br><span class="line">        <span class="comment">// 可能是 ckpt 后面，也可能是 orphan 后面</span></span><br><span class="line">        page = grab_meta_page(sbi, blkaddr++);</span><br><span class="line">        kaddr = (<span class="type">unsigned</span> <span class="type">char</span> *)page_address(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 1: write nat cache */</span></span><br><span class="line">        <span class="comment">// 写入HOT_DATA存放的NAT jorunal</span></span><br><span class="line">        seg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr, &amp;seg_i-&gt;sum_blk-&gt;n_nats, SUM_JOURNAL_SIZE);</span><br><span class="line">        written_size += SUM_JOURNAL_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 2: write sit cache */</span></span><br><span class="line">        <span class="comment">// 写入COLD_DATA存放的SIT journal</span></span><br><span class="line">        seg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);</span><br><span class="line">        <span class="built_in">memcpy</span>(kaddr + written_size, &amp;seg_i-&gt;sum_blk-&gt;n_sits,</span><br><span class="line">                                                SUM_JOURNAL_SIZE);</span><br><span class="line">        written_size += SUM_JOURNAL_SIZE;</span><br><span class="line"></span><br><span class="line">        set_page_dirty(page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 3: write summary entries */</span></span><br><span class="line">        <span class="comment">// 写入summary entry</span></span><br><span class="line">        <span class="keyword">for</span> (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">short</span> blkoff;</span><br><span class="line">                seg_i = CURSEG_I(sbi, i);</span><br><span class="line">                <span class="keyword">if</span> (sbi-&gt;ckpt-&gt;alloc_type[i] == SSR)</span><br><span class="line">                        blkoff = sbi-&gt;blocks_per_seg;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 定位到最后的valid summary entry前</span></span><br><span class="line">                        blkoff = curseg_blkoff(sbi, i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 依次遍历即可</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blkoff; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">                                page = grab_meta_page(sbi, blkaddr++);</span><br><span class="line">                                kaddr = (<span class="type">unsigned</span> <span class="type">char</span> *)page_address(page);</span><br><span class="line">                                written_size = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        summary = (<span class="keyword">struct</span> f2fs_summary *)(kaddr + written_size);</span><br><span class="line">                        *summary = seg_i-&gt;sum_blk-&gt;entries[j];</span><br><span class="line">                        written_size += SUMMARY_SIZE;</span><br><span class="line">                        set_page_dirty(page);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// page还没满</span></span><br><span class="line">                        <span class="keyword">if</span> (written_size + SUMMARY_SIZE &lt;= PAGE_CACHE_SIZE -</span><br><span class="line">                                                        SUM_FOOTER_SIZE)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                        f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">                        page = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">                f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">write_normal_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">                                        <span class="type">block_t</span> blkaddr, <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i, end;</span><br><span class="line">        <span class="comment">// type 在这里传入 CURSEG_HOT_DATA</span></span><br><span class="line">        <span class="keyword">if</span> (IS_DATASEG(type))</span><br><span class="line">                end = type + NR_CURSEG_DATA_TYPE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                end = type + NR_CURSEG_NODE_TYPE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历DATA TYPE curseg</span></span><br><span class="line">        <span class="comment">// 总共三种温度，各写一个page，按[HOT, WARM, COLD]顺序排放在blkaddr后面</span></span><br><span class="line">        <span class="comment">// 如上面compact写入分析，blkaddr要么定位在ckpt后面，要么在orphan后面</span></span><br><span class="line">        <span class="keyword">for</span> (i = type; i &lt; end; i++) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">sum</span> =</span> CURSEG_I(sbi, i);</span><br><span class="line">                mutex_lock(&amp;sum-&gt;curseg_mutex);</span><br><span class="line">                write_sum_page(sbi, sum-&gt;sum_blk, blkaddr + (i - type));</span><br><span class="line">                mutex_unlock(&amp;sum-&gt;curseg_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> sys </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件系统 </tag>
            
            <tag> sys </tag>
            
            <tag> Linux kernel </tag>
            
            <tag> f2fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译调试内核方法</title>
      <link href="/2024/10/18/Linux-Debug/"/>
      <url>/2024/10/18/Linux-Debug/</url>
      
        <content type="html"><![CDATA[<h1>编译内核</h1><p>一、从官网上下载源码，解压。</p><p>建议下载的内核与本机内核版本一致，这样可以直接使用本机的配置文件<code>/boot/config-&#123;version_name&#125;</code>进行编译。<code>&#123;version_name&#125;</code>字符串与本机的linux内核版本相关，如<code>/boot/config-5.4.0</code>。</p><h2 id="二、编译之前，首先安装编译需要的依赖包">二、编译之前，首先安装编译需要的依赖包</h2><p>ubuntu下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison pkg-config dwarves</span><br></pre></td></tr></table></figure><h2 id="三、进入下载的源码根目录，并将本机的配置信息拷贝到此处，命名为-config">三、进入下载的源码根目录，并将本机的配置信息拷贝到此处，命名为.config</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -v /boot/config-`<span class="built_in">uname</span> -r` .config</span><br></pre></td></tr></table></figure><p>使用这种方式可以沿用本机很多适合的配置，不必在接下来的配置过程中去处理过多不熟悉的配置项。</p><h2 id="四、额外配置">四、额外配置</h2><h3 id="配置文件中的额外配置">配置文件中的额外配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>该命令会开启一个用户界面，允许重新设定配置项并写入.config文件中。</p><ol><li>如果需要编译出的内核能够调试，一般需要设置这些配置项（如果是从本机复制的.config，这些项默认都是配置好的，不用再手动设置，可以在编译前确认一遍）：</li></ol><ul><li>CONFIG_KGDB</li><li>CONFIG_KGDB_SERIAL_CONSOLE：使KGDB通过串口与主机通信(打开这个选项，默认会打开CONFIG_CONSOLE_POLL和CONFIG_MAGIC_SYSRQ)</li><li>CONFIG_KGDB_KDB</li><li>CONFIG_DEBUG_KERNEL</li><li>CONFIG_DEBUG_INFO</li><li>CONFIG_FRAME_POINTER</li><li><strong>注释</strong>CONFIG_DEBUG_RODATA：使某些架构下，只读区域可增加断点</li><li><strong>注释</strong>CONFIG_CC_OPTIMIZE_FOR_SIZE，否则使用-Os</li><li>CONFIG_KALLSYMS</li><li>CONFIG_DEBUG_SECTION_MISMATCH：去掉inline优化（此条存疑，不确定功能是否为去掉inline，且设置该项为y后编译不通过）</li></ul><ol start="2"><li><p>一般会默认打开的一个配置项 CONFIG_RANDOMIZE_BASE，此处手动把它注释，禁止地址随机化。</p></li><li><p>如果有网口连接KGDB的需求，打开这些配置项</p></li></ol><ul><li><p>CONFIG_NETCONSOLE (Networking support -&gt; Network console logging support)</p></li><li><p>CONFIG_KGDB_ETH (Kernel hacking -&gt; KGDB -&gt; Method of KGDB communication -&gt; Ethernet)</p></li></ul><h3 id="Makefile的额外配置">Makefile的额外配置</h3><p>修改源码根目录的Makefile文件，将其中的-O2全部改为-O1，尽可能方便调试。（不能改成-O0，否则编译过不了）</p><h2 id="五、编译与安装">五、编译与安装</h2><ol><li>在源码根目录下运行<code>make</code>命令进行编译。</li><li>编译完成后，运行<code>sudo make modules_install</code>安装以模块方式编译的内核。</li><li>运行<code>sudo make install</code>安装内核镜像。该命令会自动生成新内核的initramfs/initrd，并更新grub中的多内核引导。</li><li>修改<code>/etc/default/grub</code>文件，将其中的<code>GRUB_TIMEOUT_STYLE=hidden</code>注释掉，并修改<code>GRUB_TIMEOUT = 10</code>，以流出10秒时间让用户选择进入哪个内核。完成后，执行<code>update-grub</code>命令并重启系统。</li><li>确认新内核安装成功后，可以进入源码目录执行<code>make clean</code>，删除编译时产生的中间文件。</li></ol><h2 id="六、可能遇到的其它问题">六、可能遇到的其它问题</h2><ul><li><p>编译时报错：debian/certs/debian-uefi-certs.pem，由certs/x509_certificate_list需求停止。或：No rule to make target 'debian/canonical-certs.pem<br>在.config中，找到CONFIG_SYSTEM_TRUSTED_KEYS，将其设置为空，即<code>CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot;</code>；或在源码根目录运行下面两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scripts/config --<span class="built_in">disable</span> SYSTEM_TRUSTED_KEYS</span><br><span class="line">scripts/config --<span class="built_in">disable</span> SYSTEM_REVOCATION_KEYS</span><br></pre></td></tr></table></figure><p>然后重新编译。</p></li><li><p>编译时报错：failed: load btf from vmlinux: invalid argument.可能是pahole版本过高，BTF格式不兼容导致的，将该软件包降级即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt-cache policy pahole</span><br><span class="line">$ <span class="built_in">sudo</span> apt install pahole=1.22-8</span><br></pre></td></tr></table></figure></li></ul><h1>调试内核</h1><h2 id="准备步骤">准备步骤</h2><ol><li><p>进行编译的机器为目标机，还需要再开一台虚拟机做开发机，两台机器通过串口连接，才能调试内核。</p></li><li><p>开发机只需要解压的源码（无需编译），以及目标机上编译出的<code>vmlinux</code>文件（将其放到开发机源码目录）。</p></li><li><p>配置两台虚拟机之间的串口。</p></li></ol><ul><li><p>开发机</p></li><li><p>目标机</p><p>与开发机相同，创建串口，把命名管道下的“客户端”改成“服务器端”即可。</p></li></ul><ol start="4"><li><p>进行串口测试：目标机执行<code>#cat /dev/ttyS1</code>，开发机执行<code>#echo &quot;test&quot; &gt; /dev/ttyS1</code>。如果目标机上能看到<code>test</code>输出，则串口配置OK。</p></li><li><p>配置目标机的<code>grub.cfg</code>：</p></li></ol><p>修改/etc/default/grub文件，增加一行：</p><p><code>GRUB_CMDLINE_LINUX=&quot;nokaslr rootdelay=90quiet splash text kgdboc=ttyS1,115200&quot;</code></p><p>其中，115200 为串口波特率，nokaslr禁止了内核地址随机化（如果配置时已经设置了CONFIG_RANDOMIZE_BASE，则这里可以不用添加nokaslr）</p><h2 id="调试方法">调试方法</h2><ul><li><p>目标机</p><p>执行<code>echo ttyS0 &gt; /sys/module/kgdboc/parameters/kgdboc</code>和<code>echo g &gt; /proc/sysrq-trigger</code>，控制交给kgdb，目标机进入假死状态，等待开发机的gdb连接。</p></li><li><p>开发机</p><p>进入内核源码目录，<code>gdb ./vmlinux</code>启动gdb。</p><p>gdb配置项：</p><ol><li>设置串口波特率，此处设置与目标机grub中相同的值。</li></ol><p><code>set serial baud 115200</code></p><ol start="2"><li>通过串口连接kgdb</li></ol><p><code>target remote /dev/ttyS1</code></p><p>可以在源码目录下新建一个<code>.gdbinit</code>文件，文件中写入以上两项。gdb启动时，会读取工作目录下的<code>.gdbinit</code>文件并运行其中的命令，这样，就不必在每次启动gdb时都进行配置。</p></li></ul><p>开发机中运行continue，使目标机得以继续运行，直到命中断点，或显式地执行命令将控制交给kgdb，然后开发机能够继续调试。</p>]]></content>
      
      
      <categories>
          
          <category> sys </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sys </tag>
            
            <tag> Linux kernel </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCIE学习笔记（一）PCI</title>
      <link href="/2024/10/18/PCIE-NOTE-1/"/>
      <url>/2024/10/18/PCIE-NOTE-1/</url>
      
        <content type="html"><![CDATA[<p>PCI是 Peripheral Component Interconnect (外设部件互连标准)的缩写，它曾经是个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。目前该总线已经逐渐被PCI Express总线所取代。</p><h2 id="PCI-总线">PCI 总线</h2><p>PCI 总线是一种树型结构，并且独立于 CPU 总线，可以和 CPU 总线并行操作。PCI总线上可以挂接 PCI 设备和 PCI 桥， PCI 总线上只允许有一个 PCI 主设备（同一时刻），其他的均为 PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p><p><img src="/img/Artical/PCIE/image.png" alt="PCI device tree"></p><h2 id="PCI-配置空间">PCI 配置空间</h2><p>PCI 配置空间为256字节的固定空间，负责设备的信息提供和管理等。头部最开始的 deviceID 和 vendorID 寄存器由 pcisig 分配，只读，vendorID 代表 pci 设备的厂商，deviceID 代表厂商的具体设备。</p><h3 id="Header-Type">Header Type</h3><p><code>0xE</code>偏移处是设备的 header type，决定了 PCI 配置头的布局和设备的类型。头类型有三种，在 PCIE 中只保留了前两种。</p><p>Type 0设备代表 PCI Endpoint，其配置空间如下：</p><p><img src="/img/Artical/PCIE/image-2.png" alt="type 0 pci configuration header layout"></p><p>每个字段的详细含义可以参照 <a href="https://wiki.osdev.org/PCI#Command_Register">PCI - OSDev Wiki</a></p><h3 id="Base-Address-Register-BAR寄存器">Base Address Register - BAR寄存器</h3><p>除了配置空间以外，PCI 还有空间去实现所需的功能，如硬件存储等，这就需要额外的可访问地址。BAR 寄存器存储了设备内部空间映射到对应地址空间的基址，它并不是一个单纯的地址，它拥有自己的结构。</p><p><img src="/img/Artical/PCIE/image-3.png" alt="bar layout"></p><p>其中：</p><ul><li><p>最低位Bit 0：是一个标志位，用于描述地址空间的类型，0表示内存地址空间，1表示 IO 地址空间</p></li><li><p>Memory Space中的Bit [2:1] - Type：用于描述内存空间的类型，00表示32位地址空间，10表示64位地址空间</p></li><li><p>Memory Space中的Bit 3 - Prefetchable：用于描述内存空间是否支持预取，0表示不支持，1表示支持。如果一段内存空间支持预取，它意味着读取时不会产生任何副作用，所以CPU可以随时将其预取到DRAM中。而如果预取被启用，在读取数据时，内存控制器也会先去DRAM查看是否有缓存。当然，这是一把双刃剑，如果数据本身不支持预取，那么除了可能导致数据不一致，多一次DRAM的查询还会导致速度下降。</p></li></ul><p>为得到所需映射空间的大小，在 BIOS 对 BAR 进行初始化时，对 BAR 寄存器写入全1，出去最低几位的 flag，对齐位会恢复为全0，高位能写入的位为全1，就可以求出所需的大小。比如0xFFFFF000，取反之后就是0x00000FFF，加1之后就是0x00001000，也就是4KB。另外，如何这个空间不可用，那么返回全0。BIOS接着进行真正的地址分配和映射，并将这个新的地址重新写入BAR。</p><p>对于BAR空间中保存的所有的地址，我们都可以通过lspci来查看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lspci -s `BUS_NUM`:00.0 -nn -vv</span><br></pre></td></tr></table></figure><h2 id="地址空间">地址空间</h2><p>PCI 定义了三个地址空间，分别为 Memory Address Space, I/O Address Space, Configuration Address Space，即内存地址空间，IO 地址空间和配置地址空间，其中第三个应和配置空间区别开。</p><p>BAR 中储存的地址可以是内存地址空间中的，也可以是 IO 地址空间的，其访问就是和 x86 系统中一样的访问方式。配置地址空间的访问需要发送事务层的指令（Configuration Commands）。</p><h2 id="BDF-Bus-Number-Device-Number-Function-Number">BDF - Bus Number, Device Number, Function Number</h2><p>PCI 上所有的设备，无论是 Type 0还是 Type 1，在系统启动的时候，都会被分配一个唯一的地址，它有三个部分组成：</p><ul><li>Bus Number：8 bits，也就是最多256条总线</li><li>Device Number：5 bits，也就是最多32个设备</li><li>Function Number：3 bits，也就是最多8个功能</li></ul><p>这就是我们常说的BDF，它类似于网络中的IP地址，一般写作 <code>BB:DD.F</code> 的格式。在 Linux 上，我们可以通过 lspci 命令来查看每个设备的 BDF 。比如，下面这个FCH SMBus Controller就是00:14.0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -t -v</span><br><span class="line"> # [Domain:Bus]</span><br><span class="line"> \-[0000:00]-+-00.0  Advanced Micro Devices, Inc. [AMD] Starship/Matisse Root Complex</span><br><span class="line">         # Device.Function</span><br><span class="line">             +-14.0  Advanced Micro Devices, Inc. [AMD] FCH SMBus Controller</span><br></pre></td></tr></table></figure><p>知道了任何一个设备的BDF之后，我们就可以通过<code>lspci -s `BDF` -vv</code>查看到这个设备的详细信息。</p><p>可以算出 PCI 配置地址空间的总大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>⋅</mo><msup><mn>2</mn><mn>5</mn></msup><mo>⋅</mo><msup><mn>2</mn><mn>3</mn></msup><mo>⋅</mo><mn>256</mn><mtext> </mtext><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>=</mo><mn>16</mn><mrow><mi mathvariant="bold">M</mi><mi mathvariant="bold">B</mi></mrow></mrow><annotation encoding="application/x-tex">2^8 \cdot 2^5 \cdot 2^3 \cdot 256 \ bytes = 16\mathbf{MB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">256</span><span class="mspace"> </span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">es</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord">16</span><span class="mord"><span class="mord mathbf">MB</span></span></span></span></span></p><h2 id="Linux-中的-PCI-子系统">Linux 中的 PCI 子系统</h2><h2 id="参考文献">参考文献</h2><p><a href="https://blog.chinaaet.com/justlxy/p/5100053251">PCIe扫盲</a></p><p><a href="https://r12f.com/posts/pcie-1-basics/#Switch">PCIe（一） —— 基础概念与设备树 | Soul Orbit (r12f.com)</a></p><p><a href="https://r12f.com/posts/pcie-2-config/#Type-0%E9%85%8D%E7%BD%AE%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%93%E6%9E%84">PCIe（二） —— 配置空间 | Soul Orbit (r12f.com)</a></p><p><a href="https://lekensteyn.nl/files/docs/PCI_SPEV_V3_0.pdf">PCI_SPEV_V3_0.pdf (lekensteyn.nl)</a></p>]]></content>
      
      
      <categories>
          
          <category> sys </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sys </tag>
            
            <tag> Linux kernel </tag>
            
            <tag> PCIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记II 多层感知机</title>
      <link href="/2023/08/16/2023-8-16%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2023/08/16/2023-8-16%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>玩樱之诗玩的</p><span id="more"></span><h1>隐藏层与激活函数</h1><h2 id="隐藏层">隐藏层</h2><blockquote><p>我们通过矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>d</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{X} \in \mathbb{R}^{n \times d}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7252em;vertical-align:-0.0391em;"></span><span class="mord mathbf">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span></span></span></span></span>来表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个样本的小批量， 其中每个样本具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span>个输入特征。 对于具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>个隐藏单元的单隐藏层多层感知机， 用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>n</mi><mo>×</mo><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{H} \in \mathbb{R}^{n \times h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7252em;vertical-align:-0.0391em;"></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span>表示隐藏层的输出， 称为<em>隐藏表示</em>（hidden representations）。 在数学或代码中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">H</span></span></span></span>也被称为<em>隐藏层变量</em>（hidden-layer variable） 或<em>隐藏变量</em>（hidden variable）。 因为隐藏层和输出层都是全连接的， 所以我们有隐藏层权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>d</mi><mo>×</mo><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}^{(1)} \in \mathbb{R}^{d \times h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9271em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span>和隐藏层偏置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mn>1</mn><mo>×</mo><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{b}^{(1)} \in \mathbb{R}^{1 \times h}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9271em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span>以及输出层权重<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>h</mi><mo>×</mo><mi>q</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{W}^{(2)} \in \mathbb{R}^{h \times q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9271em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span></span>和输出层偏置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mn>1</mn><mo>×</mo><mi>q</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathbf{b}^{(2)} \in \mathbb{R}^{1 \times q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9271em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathbf">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">×</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span></span></span></span></span></span></span></span></p></blockquote><p>在仿射变换之后对每个隐藏单元应用非线性的<em>激活函数</em><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">H</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="bold">X</mi><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">O</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">H</mi><msup><mi mathvariant="bold">W</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><msup><mi mathvariant="bold">b</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{split}\begin{aligned}    \mathbf{H} &amp; = \sigma(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}), \\    \mathbf{O} &amp; = \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}.\\\end{aligned}\end{split}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.496em;vertical-align:-1.498em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.998em;"><span style="top:-3.998em;"><span class="pstrut" style="height:3.848em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">H</span></span></span><span style="top:-2.312em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathbf">X</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span></span></span><span style="top:-2.312em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">H</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.498em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>隐藏层可以继续堆叠，从而产生更有表达能力的模型</p><h2 id="激活函数">激活函数</h2><h3 id="ReLU函数"><code>ReLU</code>函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">ReLU</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{ReLU}(x) = \max(x, 0).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">ReLU</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.relu(x)</span><br></pre></td></tr></table></figure><blockquote><p>使用ReLU的原因是，它求导表现得特别好：要么让参数消失，要么让参数通过。 这使得优化表现得更好，并且ReLU减轻了困扰以往神经网络的梯度消失问题</p></blockquote><p>当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。 注意，当输入值精确等于0时，ReLU函数不可导。 在此时，我们默认使用左侧的导数，即当输入为0时导数为0。</p><p>变体（能通过负参数的信息）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">pReLU</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{pReLU}(x) = \max(0, x) + \alpha \min(0, x).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">pReLU</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><h3 id="sigmoid函数"><code>sigmoid</code>函数</h3><p>对于一个定义域在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>中的输入， <em>sigmoid函数</em>将输入变换为区间(0, 1)上的输出。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">sigmoid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{sigmoid}(x) = \frac{1}{1 + \exp(-x)}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">sigmoid</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2574em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = torch.sigmoid(x)</span><br></pre></td></tr></table></figure><p>sigmoid函数平滑，定义域内处处可导。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mi mathvariant="normal">sigmoid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mo>=</mo><mi mathvariant="normal">sigmoid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi mathvariant="normal">sigmoid</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{d}{dx} \operatorname{sigmoid}(x) = \frac{\exp(-x)}{(1 + \exp(-x))^2} = \operatorname{sigmoid}(x)\left(1-\operatorname{sigmoid}(x)\right).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mord mathrm">sigmoid</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">sigmoid</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop"><span class="mord mathrm">sigmoid</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span></span></span></span></p><p>在0处导数取到最大0.25，图像为单峰。</p><h3 id="tanh函数"><code>tanh</code>函数</h3><p>对于一个定义域在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span>中的输入， <em>tanh函数</em>将输入变换为区间(-1, 1)上的输出。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">tanh</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>+</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\operatorname{tanh}(x) = \frac{1 - \exp(-2x)}{1 + \exp(-2x)}.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">tanh</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = torch.tanh(x)</span><br></pre></td></tr></table></figure><p>导数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>x</mi></mrow></mfrac><mi mathvariant="normal">tanh</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><msup><mrow><mi mathvariant="normal">tanh</mi><mo>⁡</mo></mrow><mn>2</mn></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\frac{d}{dx} \operatorname{tanh}(x) = 1 - \operatorname{tanh}^2(x).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mord mathrm">tanh</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.1484em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">tanh</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984em;"><span style="top:-3.1473em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>在0处导数取到最大1，图像为单峰。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记I 线性回归</title>
      <link href="/2023/08/02/2023-8-2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/02/2023-8-2%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>为了进组开始机器学习</p><p>唉，不想练车</p><span id="more"></span><h1>线性回归</h1><h2 id="线性模型">线性模型</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover><mo>=</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="bold">⊤</mi></msup><mi mathvariant="bold">x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\hat{y} = \mathbf{w}^\mathbf{\top}\mathbf{x} +b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">⊤</span></span></span></span></span></span></span></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p><h2 id="损失函数">损失函数</h2><p>样本<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>的预测值为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\hat{y}^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span>，其相应的真实标签为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">y^{(i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0824em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mover accent="true"><mi>y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.04em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>总误差为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mrow><mo fence="true">(</mo><msup><mi mathvariant="bold">w</mi><mi mathvariant="normal">⊤</mi></msup><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>+</mo><mi>b</mi><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.354em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p>训练参数使损失最小</p><h2 id="小批量随机梯度下降">小批量随机梯度下降</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>←</mo><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mfrac><mi>η</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">B</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">B</mi></mrow></munder><msub><mi mathvariant="normal">∂</mi><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow></msub><msup><mi>l</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">w</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.4293em;vertical-align:-1.3217em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal" style="margin-right:0.03041em;">B</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8557em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.03041em;">B</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">w</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">b</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span></p><p>梯度下降的方向进行</p><h1>softmax回归</h1><p>用于分类问题</p><h2 id="softmax函数"><code>softmax</code>函数</h2><p><code>softmax</code>函数是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>维向量向一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>维向量的映射。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo>=</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">f</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">m</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">x</mi></mrow><mrow><mo fence="true">(</mo><mi mathvariant="bold">o</mi><mo fence="true">)</mo></mrow><mtext> </mtext><mo separator="true">,</mo><mtext> 其中</mtext><mtext>  </mtext><mover accent="true"><msub><mi mathvariant="script">y</mi><mi>j</mi></msub><mo>^</mo></mover><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>∈</mo><mrow><mo fence="true">(</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\mathbf{y}} = \mathbf{softmax}\left(\mathbf{o}\right) \ , \ \text{其中} \; \hat{\mathcal{y}_j}=\frac{\exp(o_j)}{\sum_k\exp(o_k)} \in \left( 0, 1 \right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9023em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathbf">softmax</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">o</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord text"><span class="mord cjk_fallback">其中</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4127em;vertical-align:-0.9857em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">]</span></span></span></span></span></span></p><p>函数值满足概率的条件，并且不会改变<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">o</mi></mrow><annotation encoding="application/x-tex">\mathbf{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">o</span></span></span></span>之间的大小次序，故<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">argmax</mi><mo>⁡</mo></mrow><mi>j</mi></msub><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub><mo>=</mo><msub><mrow><mi mathvariant="normal">argmax</mi><mo>⁡</mo></mrow><mi>j</mi></msub><msub><mi>o</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\operatorname*{argmax}_j \hat y_j = \operatorname*{argmax}_j o_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0747em;vertical-align:-0.3802em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">argmax</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3802em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8108em;vertical-align:-0.3802em;"></span><span class="mop"><span class="mop"><span class="mord mathrm">argmax</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2175em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3802em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></p><blockquote><p>尽管softmax是一个非线性函数，但softmax回归的输出仍然由输入特征的仿射变换决定。 因此，softmax回归是一个<em>线性模型</em>（linear model）。</p></blockquote><p>实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition  <span class="comment"># 这里应用了广播机制</span></span><br></pre></td></tr></table></figure><h2 id="矢量化模型">矢量化模型</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">O</mi><mo>=</mo><mi mathvariant="bold">X</mi><mi mathvariant="bold">W</mi><mo>+</mo><mi mathvariant="bold">b</mi><mo separator="true">,</mo><mspace linebreak="newline"></mspace><mover accent="true"><mi mathvariant="bold">Y</mi><mo>^</mo></mover><mo>=</mo><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">f</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">m</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">x</mi></mrow><mrow><mo fence="true">(</mo><mi mathvariant="bold">O</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{O} = \mathbf{X}\mathbf{W} + \mathbf{b} ,\\\hat{\mathbf{Y}} = \mathbf{softmax}\left(\mathbf{O}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">O</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7694em;vertical-align:-0.0833em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">XW</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathbf">b</span><span class="mpunct">,</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.9495em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9495em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span><span style="top:-3.2551em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;"><span class="mord">^</span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">softmax</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">O</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>数据集中单个样本的标签是一个整数表示类别编号，模型的输出单个样本的预测是一个向量。</p><h2 id="最大似然估计">最大似然估计</h2><h3 id="概率和似然">概率和似然</h3><ul><li>概率(Probability)是在给定模型/分布曲线下，特定横坐标范围的面积</li><li>似然(Likelihood)是在给定事件发生的条件下，某一概率分布中该事件发生的概率</li></ul><p>给定概率分布<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>，一支概率密度函数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">f_D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，分布参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，从分布中抽出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>个值的采样<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>X</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">X_1, X_2, \dots, X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其似然函数为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">L</mi><mrow><mo fence="true">(</mo><mi>θ</mi><mo>∣</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence="true">)</mo></mrow><mo>=</mo><msub><mi>f</mi><mi>θ</mi></msub><mrow><mo fence="true">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{L}\left(\theta \mid x_1, \dots, x_n \right) = f_\theta\left(x_1, \dots, x_n\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">L</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p><p>寻找分布参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>，使似然最大。</p><h3 id="softmax模型中"><code>softmax</code>模型中</h3><p>采样为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Y</mi></mrow><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span></span></span></span>，分布参数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">X</mi></mrow><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord mathbf">X</span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi mathvariant="bold">X</mi><mo>∣</mo><mi mathvariant="bold">Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">Y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><msup><mi mathvariant="bold">y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>∣</mo><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">L(\mathbf{X} \mid \mathbf{Y}) = P(\mathbf{Y} \mid \mathbf{X}) = \prod_{i=1}^n P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathbf">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>最大化似然，即为最小化负对数似然（自然对数）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="bold">Y</mi><mo>∣</mo><mi mathvariant="bold">X</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><msup><mi mathvariant="bold">y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo>∣</mo><msup><mi mathvariant="bold">x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>l</mi><mo stretchy="false">(</mo><msup><mi mathvariant="bold">y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo separator="true">,</mo><msup><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">-\log P(\mathbf{Y} \mid \mathbf{X}) = \sum_{i=1}^n -\log P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)})= \sum_{i=1}^n l(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)}),</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.02875em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbf">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span></span></p><p>单个样本损失函数为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><mi>log</mi><mo>⁡</mo><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">l(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{j=1}^q y_j \log \hat{y}_j.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.1123em;vertical-align:-1.4138em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><p>称为交叉熵损失。显然这个求和符号的作用是取标签正确分类的那一维出来运算。实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - torch.log(y_hat[<span class="built_in">range</span>(<span class="built_in">len</span>(y_hat)), y]) <span class="comment">## 用到了一个极其抽象的切片，切片结果是一个一维张量</span></span><br><span class="line"></span><br><span class="line">cross_entropy(y_hat, y)</span><br></pre></td></tr></table></figure><p>将<code>softmax</code>函数代入得</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>l</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><mi>log</mi><mo>⁡</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><mi>log</mi><mo>⁡</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><msub><mi>o</mi><mi>j</mi></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>log</mi><mo>⁡</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><msub><mi>y</mi><mi>j</mi></msub><msub><mi>o</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{split}\begin{aligned}l(\mathbf{y}, \hat{\mathbf{y}}) &amp;=  - \sum_{j=1}^q y_j \log \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} \\&amp;= \sum_{j=1}^q y_j \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j\\&amp;= \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j.\end{aligned}\end{split}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:10.5368em;vertical-align:-5.0184em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.5184em;"><span style="top:-7.5184em;"><span class="pstrut" style="height:7.3684em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.3684em;"><span style="top:-7.3684em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.9561em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"></span></span><span style="top:-0.5439em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.8684em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.3684em;"><span style="top:-7.3684em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3057em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.9561em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.5439em;"><span class="pstrut" style="height:3.6985em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6985em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3471em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.8684em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:5.0184em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">∂</mi><msub><mi>o</mi><mi>j</mi></msub></msub><mi>l</mi><mo stretchy="false">(</mo><mi mathvariant="bold">y</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="bold">y</mi><mo>^</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>q</mi></munderover><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>−</mo><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">f</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="bold">o</mi><msub><mo stretchy="false">)</mo><mi>j</mi></msub><mo>−</mo><msub><mi>y</mi><mi>j</mi></msub><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) = \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} - y_j = \mathrm{softmax}(\mathbf{o})_j - y_j.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0973em;vertical-align:-0.3473em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3473em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.421em;vertical-align:-0.994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.3057em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8043em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">softmax</span></span><span class="mopen">(</span><span class="mord mathbf">o</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mord">.</span></span></span></span></span></p><blockquote><p>换句话说，导数是我们<code>softmax</code>模型分配的概率与实际发生的情况（由独热标签向量表示）之间的差异。 从这个意义上讲，这与我们在回归中看到的非常相似， 其中梯度是观测值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>和估计值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>y</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{y}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span></span></span></span>之间的差异。 这不是巧合，在任何指数族分布模型中， 对数似然的梯度正是由此得出的。 这使梯度计算在实践中变得容易很多。</p></blockquote><h3 id="熵与交叉熵损失">熵与交叉熵损失</h3><p>熵的方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>H</mi><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mo>∑</mo><mi>j</mi></munder><mo>−</mo><mi>P</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">H[P] = \sum_j - P(j) \log P(j).</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4638em;vertical-align:-1.4138em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mord">.</span></span></span></span></span></p><p>用信息量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mfrac><mn>1</mn><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log \frac{1}{P(j)} = -\log P(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3651em;vertical-align:-0.52em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>来量化“惊异”程度，熵是当分配的概率真正匹配数据生成过程时的<em>信息量的期望</em>。<s>非常抽象难以理解</s></p><p>可以把交叉熵想象为“主观概率为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span></span></span></span>的观察者在看到根据概率<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>生成的数据时的预期惊异”</p><p>可以从两方面来考虑交叉熵分类目标： （i）最大化观测数据的似然；（ii）最小化传达标签所需的惊异。</p><h2 id="分类精度">分类精度</h2><p>采用每个预测中预测概率最高的类作为硬预测，硬预测与标签分类一致的样本个数与总数之比作为分类精度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):  <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算预测正确的数量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y_hat.shape) &gt; <span class="number">1</span> <span class="keyword">and</span> y_hat.shape[<span class="number">1</span>] &gt; <span class="number">1</span>:</span><br><span class="line">        y_hat = y_hat.argmax(axis=<span class="number">1</span>) <span class="comment"># axis = 1 是在行中比较，选出最大的列索引，将输出转换为标签一样的格式</span></span><br><span class="line">    cmp = y_hat.<span class="built_in">type</span>(y.dtype) == y</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(cmp.<span class="built_in">type</span>(y.dtype).<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line">accuracy(y_hat, y) / <span class="built_in">len</span>(y)</span><br></pre></td></tr></table></figure><h2 id="softmax与交叉熵实现为精度进行的变化"><code>softmax</code>与交叉熵实现为精度进行的变化</h2><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{split}\begin{aligned}\hat y_j &amp; =  \frac{\exp(o_j - \max(o_k))\exp(\max(o_k))}{\sum_k \exp(o_k - \max(o_k))\exp(\max(o_k))} \\&amp; = \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}.\end{aligned}\end{split}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.7254em;vertical-align:-2.6127em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.1127em;"><span style="top:-5.1127em;"><span class="pstrut" style="height:4.9627em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9627em;"><span style="top:-4.9627em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4627em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9627em;"><span style="top:-4.9627em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.427em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4627em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.6127em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><msub><mover accent="true"><mi>y</mi><mo>^</mo></mover><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>log</mi><mo>⁡</mo><mrow><mo stretchy="false">(</mo><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>j</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>o</mi><mi>j</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><munder><mo>∑</mo><mi>k</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo>−</mo><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>o</mi><mi>k</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mi mathvariant="normal">.</mi></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{split}\begin{aligned}\log{(\hat y_j)} &amp; = \log\left( \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}\right) \\&amp; = \log{(\exp(o_j - \max(o_k)))}-\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)} \\&amp; = o_j - \max(o_k) -\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)}.\end{aligned}\end{split}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:9.7399em;vertical-align:-4.62em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.12em;"><span style="top:-7.12em;"><span class="pstrut" style="height:6.97em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.97em;"><span style="top:-7.27em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1944em;"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span style="top:-4.2343em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"></span></span><span style="top:-0.8821em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.47em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:4.97em;"><span style="top:-7.27em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1864em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span><span style="top:-4.2343em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mopen">(</span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)))</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span></span></span><span style="top:-0.8821em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.8479em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span></span><span class="mord">.</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.47em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.62em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-5-7-OOCPC学习笔记</title>
      <link href="/2023/05/07/2023-5-7-OOCPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/07/2023-5-7-OOCPC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>嗯学英文Object-oriented programming with ansci-c</p><span id="more"></span><h2 id="Chapter-4">Chapter 4</h2><p>C结构体的储存结构取决于结构体定义中成员的排列顺序，柔性数组必须排列在最后。父类的内存应放在子类的最前面，以保证类型的向上转换后的内存访问是合法的。</p><p>类的标识符以及能被重写的函数都写在class结构体里面，但是无法适用于多种类型的继承</p><p>只有构造器逐层向上构造各子类延伸部分时会调用同层函数，即使这个函数会被下层子类继承并重写</p><p>重写过程发生在new函数的一开始，因此这种调用可能无法实现。在本层构造器中应调用本层函数的原名而不是标识名。</p><p>基于信息隐藏原则，子类不应直接访问父类信息，父类应提供静态函数接口或者宏来提供访问（宏本身并不是完全安全的）</p><h1>Chapter 6</h1><p><code>classOf</code>和<code>sizeOf</code>的作用是进行错误检查后分别返回类描述和类大小。</p><p>seletor传入的参数是实例指针，作用是调用classOf返回的类描述中储存的多态函数并调用。</p><br><h1>紫辰presentation大纲</h1><h2 id="1-什么是OOP捏">1. 什么是OOP捏</h2><ul><li>oop的特性（多态，继承……）</li><li>数据结构的定义</li><li>老生常谈的编程原则</li></ul><h2 id="2-类结构组织的语言特性基础">2. 类结构组织的语言特性基础</h2><ul><li>C的结构体——一块泛化的连续内存组织</li><li>简单的类实现</li><li>文件组织（对调用者可见的接口声明文件.h，实现文件.c，仅对库内部可见的定义和实现.r）</li></ul><h2 id="3-继承和多态的初步实现">3. 继承和多态的初步实现</h2><ul><li>基类object的继承：内存平移，指针类型转换</li><li>资源占有的两种方式：继承和聚合</li><li>虚函数的继承和重写：类描述的引入，选择器的实现和指针的覆写</li><li>new/delete静态函数，ctor/dtor动态函数</li></ul><h2 id="4-类继承和类描述的组织">4. 类继承和类描述的组织</h2><ul><li>基础class和object类</li><li>metaclass的概念</li><li>class的继承和metaclass的特化</li><li>基础两个类的初始化</li></ul><h2 id="5-其他特性的实现">5. 其他特性的实现</h2><ul><li>框架化：预处理器</li><li>自动类的初始化</li><li>异常处理</li></ul><h2 id="6-杂谈">6. 杂谈</h2><ul><li>汇编实现oop</li><li>和c艹效率对比</li></ul><h2 id="需补充（？回顾）的c知识">需补充（？回顾）的c知识</h2><ul><li>可变参数列表（对比C++的形参包）</li><li>struct的组织形式，柔性数组</li><li>c的异常处理机制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> OOC </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-2-24-病毒学习笔记~文件系统</title>
      <link href="/2023/02/24/2023-2-24-%E7%97%85%E6%AF%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/24/2023-2-24-%E7%97%85%E6%AF%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>病毒前置：文件系统相关的学习笔记</p><span id="more"></span><h1>硬盘的物理结构</h1><h2 id="低级格式化">低级格式化</h2><p>低级格式化的主要目的是将盘面划分成磁道、扇区和柱面</p><h1>文件系统</h1><h2 id="基本INT-13H调用">基本INT 13H调用</h2><ul><li><p>BIOS INT 13H调用是BIOS提供的磁盘基本输入输出中断调用，它可以完成磁盘(包括硬盘和软盘)的复位、读写、校验、定位、诊断、格式化等功能，完全不用考虑被操作硬盘安装的是什么操作系统</p></li><li><p>它使用的就是CHS寻址方式</p></li><li><p>最大只能访问8GB左右的硬盘</p></li></ul><h2 id="Fat12">Fat12</h2><h3 id="Fat12的格式">Fat12的格式</h3><ul><li><p>引导扇区：记录磁盘和文件系统相关的各种参数，比如扇区大小，一簇的扇区数等（一个扇区大小）</p></li><li><p>Fat扇区：记录已分配的扇区和可用扇区，并通过链表依序记录一个文件的全部扇区（默认九个扇区大小</p></li><li><p>）</p></li><li><p>根目录区（长度不固定）：记录根目录文件项的表，文件项包括文件，目录。通过它可以查找到根目录下的文件和目录信息，比名称，大小，日期等</p></li><li><p>数据区（长度不固定）：用户数据（文件和子目录文件）存放的地方</p></li><li><p>*缺省有两个fat，1个fat9个扇区，引导扇区1个扇区，根目录区有224条记录（一个记录32字节），这些参数都都可以在引导扇区的引导记录中设定</p></li></ul><h2 id="Fat表的格式">Fat表的格式</h2><p>Fat表开始3个字节没用于用户文件分配，3字节有2组12bits所以，占用了0,1两个簇号。用户的数据从簇2开始分配。</p><p>Fat表从头开始按3字节分成一组，一组中第2字节的低半字节作为最高半字节和一组中第1字节组成整数表示一个簇号，第2字节的高半字节作为最低半字节和第3字节组成整数表示一个簇号。</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>名称</td><td>偏移</td><td>长度</td><td>内容</td><td>软盘参考值</td></tr><tr><td>BS_jmpBoot</td><td>0</td><td>3</td><td></td><td>jmp LABEL_START nop</td></tr><tr><td>BS_OEMName</td><td>3</td><td>8</td><td>厂商名</td><td>‘ForrestY’</td></tr><tr><td>BPB_BytsPerSec</td><td>11</td><td>2</td><td>每扇区字节数</td><td>0x200（即十进制512）</td></tr><tr><td>BPB_SecPerClus</td><td>13</td><td>1</td><td>每<a href="http://baike.baidu.com/subview/241650/12503090.htm">簇</a>扇区数</td><td>0x01</td></tr><tr><td>BPB_RsvdSecCnt</td><td>14</td><td>2</td><td>Boot记录占用多少扇区</td><td>0x01</td></tr><tr><td>BPB_NumFATs</td><td>16</td><td>1</td><td>共有多少FAT表</td><td>0x02</td></tr><tr><td>BPB_RootEntCnt</td><td>17</td><td>2</td><td>根目录文件数最大值（多少个32字节目录项）</td><td>0xE0 （224）</td></tr><tr><td>BPB_TotSec16</td><td>19</td><td>2</td><td>扇区总数</td><td>0xB40（2880）</td></tr><tr><td>BPB_Media</td><td>21</td><td>1</td><td>介质描述符</td><td>0xF0</td></tr><tr><td>BPB_FATSz16</td><td>22</td><td>2</td><td>每FAT扇区数</td><td>0x09</td></tr><tr><td>BPB_SecPerTrk</td><td>24</td><td>2</td><td>每磁道扇区数</td><td>0x12</td></tr><tr><td>BPB_NumHeads</td><td>26</td><td>2</td><td>磁头数</td><td>0x02</td></tr><tr><td>BPB_HiddSec</td><td>28</td><td>4</td><td>隐藏扇区数</td><td>0</td></tr><tr><td>BPB_TotSec32</td><td>32</td><td>4</td><td>如果BPB_TotSec16是0，由这个值记录扇区数</td><td>0xB40（2880）</td></tr><tr><td>BS_DrvNum</td><td>36</td><td>1</td><td>中断13的驱动器号</td><td>0</td></tr><tr><td>BS_Reserved1</td><td>37</td><td>1</td><td>未使用</td><td>0</td></tr><tr><td>BS_BootSig</td><td>38</td><td>1</td><td>扩展引导标记</td><td>0x29</td></tr><tr><td>BS_VolD</td><td>39</td><td>4</td><td>卷序列号</td><td>0</td></tr><tr><td>BS_VolLab</td><td>43</td><td>11</td><td>卷标</td><td>‘OrangeS0.02’</td></tr><tr><td>BS_FileSysType</td><td>54</td><td>8</td><td>文件系统类型</td><td>‘FAT12’</td></tr><tr><td>引导代码</td><td>62</td><td>448</td><td>引导代码、数据及其他填充字符等</td><td></td></tr><tr><td>结束标志</td><td>510</td><td>2</td><td></td><td>0xAA55</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>名称</td><td>偏移</td><td>长度</td><td>描述</td></tr><tr><td>DIR_Name</td><td>0</td><td>0xB</td><td>文件名8字节，扩展名3字节</td></tr><tr><td>DIR_Attr</td><td>0xB</td><td>1</td><td>文件属性</td></tr><tr><td>保留</td><td>0xC</td><td>10</td><td></td></tr><tr><td>DIR_WrtTime</td><td>0x16</td><td>2</td><td>最后修改时间</td></tr><tr><td>DIR_WrtDate</td><td>0x18</td><td>2</td><td>最后修改日期</td></tr><tr><td>DIR_FstClus</td><td>0x1A</td><td>2</td><td>此条目对应的开始簇号</td></tr><tr><td>DIR_FileSize</td><td>0x1C</td><td>4</td><td>文件大小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文件系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 病毒 </tag>
            
            <tag> 文件系统 </tag>
            
            <tag> sys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-1-28画板制作二-插件化改造</title>
      <link href="/2023/01/28/2023-1-28%E7%94%BB%E6%9D%BF%E5%88%B6%E4%BD%9C%E4%BA%8C-%E6%8F%92%E4%BB%B6%E5%8C%96%E6%94%B9%E9%80%A0/"/>
      <url>/2023/01/28/2023-1-28%E7%94%BB%E6%9D%BF%E5%88%B6%E4%BD%9C%E4%BA%8C-%E6%8F%92%E4%BB%B6%E5%8C%96%E6%94%B9%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<p>基础画板的插件化改造</p><span id="more"></span><h1>基础画板的问题</h1><p>上文写出的基础画板可以发现很多问题，假如将它实际应用在生产环境中会发现维护和后续开发可能会遇上麻烦。</p><h2 id="controller和graph的耦合">controller和graph的耦合</h2><p>在<code>graphcontroller</code>类中定义了<code>shape</code>枚举用于储存当前绘制的形状，但是本质只是将已知的形状手动编号，在增改形状时不仅要删改形状本身，还要修改<code>graphcontroller</code>类中的内容，并且这两者是需要在源代码中手动保持一致的，这导致后续对代码的修改变得极为麻烦且易出问题。</p><h2 id="谜语人文件编码">谜语人文件编码</h2><p>问题症结与上面类似，在文件读写之中采用编号制度储存形状，这在版本更迭时难以保证兼容性，故应为每个形状添加唯一的标识名称。</p><h2 id="形状难增删">形状难增删</h2><p>原因其中之一就是上文说的组件的耦合，另外<code>mainwindow</code>的按钮组件与图形切换的触发机制导致每个单独的形状都需要重新编写一个槽函数以及设置一堆<code>QToolBar</code>属性。</p><h2 id="绘图流程死板">绘图流程死板</h2><p>鼠标事件的处理放在了<code>GraphController</code>中统一进行，不方便加入其他类型的绘画，比如绘制多边形。</p><h1>问题的解决方案</h1><p>将<code>graphbase</code>作为静态库独立，每个形状将其继承并编写为单个dll文件，即写成一个Qt插件。这样controller和graph之间通讯时必须由前者通过后者的接口获取信息并动态创建管理组件。</p><p>每个形状有一个唯一标识字符串，并应用于文件的保存读取中。</p><h1>具体实现</h1><h2 id="静态库GraphPluginBase">静态库<code>GraphPluginBase</code></h2><p>作为画画的图形，也就是插件的基类。该类里面定义了形状的基本操作，鼠标的操作状态和命令枚举和鼠标事件函数。所有插件即dll的编写应继承自这个类。</p><h2 id="插件">插件</h2><p>每个插件包含了一个形状。在头文件中声明了形状的大写和小写名称作为唯一标识符，重载了一些功能函数和鼠标事件函数。注意<code>paint</code>函数在每个插件里面都需要重载，因为每个形状的绘图逻辑不一样；每个形状应该根据自己的绘图流程重载鼠标事件函数。插件的导出函数有三个，类实例的新建函数、名称获取函数和<code>QAction</code>的获取函数。实际上如果要使代码更加简洁可以将后两者都写到基类里面去。</p><h2 id="绘图控制类GraphController">绘图控制类<code>GraphController</code></h2><p>绘图控制类<code>GraphController</code>主要作用是接收鼠标事件和控制图形行为，是<code>MainWindow</code>的子组件。类中包含插件和图形的<code>QMap</code>或<code>QList</code>，存储了当前已经绘制的图形和已经导入的插件。类接收鼠标事件并根据鼠标时间发生的坐标将事件分发给相应的图形，如何反应又由图形本身决定。</p><h2 id="主窗体MainWindow">主窗体<code>MainWindow</code></h2><p>主窗体主要控制窗体gui插件以及主导插件导入工作，使用了大量信号和槽。</p><h2 id="形状容器ShapeContainer">形状容器<code>ShapeContainer</code></h2><p>主要用于主窗体选择形状信号的分发以及形状名称的临时保存。</p><h1>成品效果</h1><p><img src="/img/paintboard/PaintBoardShow.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-1-28画板制作笔记一</title>
      <link href="/2023/01/28/2023-1-28%E7%94%BB%E6%9D%BF%E5%88%B6%E4%BD%9C%E4%B8%80/"/>
      <url>/2023/01/28/2023-1-28%E7%94%BB%E6%9D%BF%E5%88%B6%E4%BD%9C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>进bitman时写的画板，现在写一个笔记回忆下当时的思路。</p><span id="more"></span><h1>任务内容</h1><p>写一个类似于windows画图的画板程序，要求至少提供直线，正方形和圆三种图形，支持拖拽以及文件保存读取。</p><h1>用到的Qt特性</h1><p>基于知道啥用啥的原则，选择Qt作为sdk编写。Qt的特性决定了这个程序怎么架构。</p><h2 id="信号和槽">信号和槽</h2><p>属于Qt元对象机制的内容。</p><blockquote><p>信号与槽（Signal &amp; Slot）是 Qt 编程的基础，也是 Qt 的一大创新。因为有了信号与槽的编程机制，在 Qt 中处理界面各个组件的交互操作时变得更加直观和简单。</p><p>信号（Signal）就是在特定情况下被发射的事件，例如 PushButton 最常见的信号就是鼠标单击时发射的 clicked() 信号，一个 ComboBox 最常见的信号是选择的列表项变化时发射的 CurrentIndexChanged() 信号。</p><p>槽（Slot）就是对信号响应的函数。槽是一个函数，与一般的 C++ 函数一样，可以定义在类的任何部分（public、private 或 protected），可以具有任何参数，也可以被直接调用。槽函数与一般的函数不同的是：槽函数可以与一个信号关联，当信号被发射时，关联的槽函数被自动执行。</p></blockquote><h2 id="事件机制">事件机制</h2><p>键鼠交互和图形绘制所需要。</p><blockquote><p>【1】事件</p><p>事件是可以被控件识别的操作。如按下确定按钮、选择某个单选按钮或复选框。</p><p>每种控件有自己可识别的事件，如窗体的加载、单击、双击等事件，编辑框（文本框）的文本改变事件等等。</p><p>事件就是用户对窗口上各种组件的操作。</p><p>【2】Qt事件</p><p>由窗口系统或Qt自身产生的，用以响应所发生各类事情的操作。具体点，Qt事件是一个QEvent对象，用于描述程序内部或外部发生的动作。</p><p>【3】Qt事件产生类型</p><p>1、键盘或鼠标事件：用户按下或松开键盘或鼠标上的按键时，就可以产生一个键盘或者鼠标事件。</p><p>2、绘制事件：某个窗口第一次显示的时候，就会产生一个绘制事件，用来告诉窗口需要重新绘制它本身，从而使得该窗口可见。</p><p>3、QT事件：Qt自己也会产生很多事件，比如QObject::startTimer()会触发QTimerEvent。</p></blockquote><p>另外还用到了元对象机制的其他内容，如内存管理之类。</p><h1>基本构想</h1><h2 id="绘图">绘图</h2><p>设计一个<code>graphcontroller</code>类，包含成员画板<code>QPainter</code>类实例，管理所有的图形和键鼠与画板之间的互动。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphController</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GraphController</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">        line = <span class="number">0</span>, ellipse = <span class="number">1</span>, rectangle = <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">        drag, creat, null</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">QList&lt;GraphBase*&gt;* <span class="title">GetList</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ChangeShape</span><span class="params">(GraphController::Shape)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">paintEvent</span><span class="params">(QPaintEvent*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent*)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyPressEvent</span><span class="params">(QKeyEvent*)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">keyReleaseEvent</span><span class="params">(QKeyEvent*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;GraphBase*&gt; ShapeList;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> order_stamp;</span><br><span class="line">    Shape current_shape;</span><br><span class="line">    Status now_sta;</span><br><span class="line">    GraphBase* current_graph;</span><br><span class="line">    QPoint relative;</span><br><span class="line">    <span class="type">bool</span> now_shifted;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>graphcontroller</code>类中使用链表管理当前已经画上的图形，即储存图形抽象类的指针。</p><p>当鼠标按下时，通过事件机制获取当前坐标，此时要判断要进行拖拽还是创建新图形。遍历已画的图形判断即可。</p><p>新建图形时，需记录当前选中的形状；拖拽时，找出顺序戳最前的图形进行选中。另外记录shift键是否按下来绘制方形。接收鼠标位移事件时判断当前画板状态并计算相对位移，注意qt窗口的坐标机制。</p><h2 id="形状">形状</h2><p>所有形状继承自抽象类<code>graphbase</code>，重载实现所有功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GraphBase</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GraphBase</span><span class="params">(QPoint Spos, QPoint Epos, <span class="type">int</span> order, QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">order</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(QPoint, QPoint)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(QPoint)</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">StartPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">QPoint <span class="title">EndPoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fixpos</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">paint</span><span class="params">(QPainter&amp;)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">inrange</span><span class="params">(QPoint)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Shape_type</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    QPoint Spos, Epos;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(qreal, qreal, qreal)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">between</span><span class="params">(qreal val, qreal a, qreal b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> graph_order;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个子类要实现三个功能，分别为调用画板绘制当前图形，判断某个点是否位于当前图形上，返回当前图形形状值（这种做法其实不好）。</p><h2 id="文件操作">文件操作</h2><p>以特定的文字格式输出到某个文件后方便读取，迭代器遍历<code>graphcontroller</code>类中的链表即可。也可以设计输出到二进制文件中，甚至加密。</p><h2 id="主窗口">主窗口</h2><p>新建子组件<code>graphcontroller</code>类以及一堆<code>ToolBar</code>，使窗口上面是工具栏下面是画板。工具栏排布保存加载按钮以及图形选择按钮。</p><h1>实现细节</h1><h2 id="主窗口与graphcontroller类通讯">主窗口与<code>graphcontroller</code>类通讯</h2><p>改变当前形状的时候触发<code>mainwindow</code>定义的信号，由<code>graphcontroller</code>类接收。</p><h2 id="图形坐标">图形坐标</h2><p>注意基类中记录的图形坐标位于该图形的哪个相对位置，尤其是绘制时和判断点是否在图形上时。</p><h2 id="线段">线段</h2><p>线段判断点是否在图形上时，如果采用斜率判断需要特判竖直的情况；如果采用将式子乘开的绝对误差判断则需要与相应的分母作为基准值比较。</p><h1>成品效果</h1><p><img src="/img/paintboard/paintboard1.png" alt=""></p><h1>总结</h1><p>不同sdk用的gui机制不同，qt可能算是相对简单的。实际上第一次写完出成品问题挺大的，绘图bug很多，只是勉强能用，所以图形逻辑一定要设计好。</p><p>新手入门Qt渣作。源代码请私聊我喵。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python杂记</title>
      <link href="/2022/11/16/2022-11-16-python%E6%9D%82%E8%AE%B0/"/>
      <url>/2022/11/16/2022-11-16-python%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>其他学习中碰到的python知识，做一个杂烩记录</p><span id="more"></span><h1>迭代器和可迭代对象</h1><p>迭代器是一个带状态的对象，它能在你调用<code>next()</code>方法时返回容器中的下一个值，任何实现了<code>__iter__()</code>和<code>__next__()</code>方法的对象都是迭代器，<code>__iter__()</code>返回迭代器自身，<code>__next__()</code>返回容器中的下一个值，如果容器中没有更多元素了，则抛出<code>StopIteration</code>异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fab</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>): </span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">max</span> = <span class="built_in">max</span> </span><br><span class="line">        <span class="variable language_">self</span>.n, <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.n &lt; <span class="variable language_">self</span>.<span class="built_in">max</span>: </span><br><span class="line">            r = <span class="variable language_">self</span>.b </span><br><span class="line">            <span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b = <span class="variable language_">self</span>.b, <span class="variable language_">self</span>.a + <span class="variable language_">self</span>.b </span><br><span class="line">            <span class="variable language_">self</span>.n = <span class="variable language_">self</span>.n + <span class="number">1</span> </span><br><span class="line">            <span class="keyword">return</span> r </span><br><span class="line">        <span class="keyword">raise</span> StopIteration()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> Fab(<span class="number">5</span>): </span><br><span class="line">    <span class="built_in">print</span> n</span><br></pre></td></tr></table></figure><h1>生成器</h1><p>了解了迭代器之后，我们来看下生成器，普通函数用<code>return</code>返回一个值,还有一种函数用<code>yield</code>返回值，这种函数叫生成器函数。函数被调用时会返回一个生成器对象。生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅，它不需要像普通迭代器一样实现<code>__iter__()</code>和<code>__next__()</code>方法了，只需要一个<code>yield</code>关键字。生成器一定是迭代器（反之不成立），因此任何生成器也是一种懒加载的模式生成值。</p><p><code>yield</code>就是<code>return</code>返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后（下一行）开始。<code>next</code>方法和<code>send</code>方法都可以返回下一个元素，区别在于<code>send</code>可以传递参数给<code>yield</code>表达式，这时传递的参数会作为yield表达式的值，而yield的参数是返回给调用者的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params"><span class="built_in">max</span></span>): </span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> </span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>: </span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b </span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>): </span><br><span class="line">    <span class="built_in">print</span> n</span><br></pre></td></tr></table></figure><h1>列表list</h1><p>包含以下函数:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">函数</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>包含以下方法:</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-pop.html">list.pop([index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><h1>元组tuple</h1><p>元组包含了以下内置函数</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法及描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">len(tuple) 计算元组元素个数。</td><td style="text-align:left"><code>&gt;&gt;&gt; tuple1 = ('Google', 'Runoob', 'Taobao') &gt;&gt;&gt; len(tuple1) 3 &gt;&gt;&gt; </code></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">max(tuple) 返回元组中元素最大值。</td><td style="text-align:left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; max(tuple2) '8' &gt;&gt;&gt; </code></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">min(tuple) 返回元组中元素最小值。</td><td style="text-align:left"><code>&gt;&gt;&gt; tuple2 = ('5', '4', '8') &gt;&gt;&gt; min(tuple2) '4' &gt;&gt;&gt; </code></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">tuple(iterable) 将可迭代系列转换为元组。</td><td style="text-align:left"><code>&gt;&gt;&gt; list1= ['Google', 'Taobao', 'Runoob', 'Baidu'] &gt;&gt;&gt; tuple1=tuple(list1) &gt;&gt;&gt; tuple1 ('Google', 'Taobao', 'Runoob', 'Baidu')</code></td></tr></tbody></table><p>元组中元素不可修改</p><h1>range函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">range(stop)</span><br><span class="line">range(start, stop[, step])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;</li><li>stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</li><li>step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</li></ul><h1>with 关键字</h1><p>（１）紧跟with后面的语句被求值后，返回对象的“_<em>enter</em>_()”方法被调用，这个方法的返回值将被赋值给as后面的变量；<br>（２）当with后面的代码块全部被执行完之后，将调用前面返回对象的“–exit–()”方法。<br>with工作原理代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;in __enter__&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Foo&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;in __exit__&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sample</span>():</span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"><span class="keyword">with</span> get_sample() <span class="keyword">as</span> sample:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Sample: &quot;</span>, sample12345678910</span><br></pre></td></tr></table></figure><p>代码的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in __enter__</span><br><span class="line">Sample:  Foo</span><br><span class="line">in __exit__123</span><br></pre></td></tr></table></figure><p>可以看到，整个运行过程如下：<br>（１）<strong>enter</strong>()方法被执行；<br>（２）<strong>enter</strong>()方法的返回值，在这个例子中是”Foo”，赋值给变量sample；<br>（３）执行代码块，打印sample变量的值为”Foo”；<br>（４）<strong>exit</strong>()方法被调用；</p><h1>星号的使用</h1><ul><li><p>单星号：解包器，传参时用，将列表之类的容器解包后传递出多个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c</span>) :</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">func(*a)</span><br></pre></td></tr></table></figure></li><li><p>双星号：打包器，函数定义时用，将传入的参数打包为字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**a</span>) :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a.items() :</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"> </span><br><span class="line">func(x = <span class="number">1</span>, y = <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 语法 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记</title>
      <link href="/2022/11/16/2022-11-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/16/2022-11-16-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>为了互导的论文，开始学深度学习了。</p><span id="more"></span><h1><em>pytorch</em>的使用</h1><h2 id="torch-normal"><code>torch.normal</code></h2><ul><li><p>作用：生成一个正态分布的张量</p></li><li><p><code>torch.normal(mean, std, size)</code></p><p>三个参数分别为均值，标准差和size</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.normal(<span class="number">3</span>, <span class="number">0.1</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">tensor([[<span class="number">2.9425</span>, <span class="number">3.1877</span>, <span class="number">2.9735</span>, <span class="number">3.0982</span>],</span><br><span class="line">        [<span class="number">3.0061</span>, <span class="number">2.9918</span>, <span class="number">2.7953</span>, <span class="number">3.0066</span>],</span><br><span class="line">        [<span class="number">2.8219</span>, <span class="number">2.9578</span>, <span class="number">2.8813</span>, <span class="number">2.9014</span>]])</span><br></pre></td></tr></table></figure></li><li><p><code>torch.normal(mean, stds)</code></p><p>两个参数分别为:均值和标准差，使用标准差来确定范围size</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.normal(<span class="number">3</span>, torch.ones(<span class="number">3</span>, <span class="number">4</span>)/<span class="number">10</span>)</span><br><span class="line">tensor([[<span class="number">2.8491</span>, <span class="number">3.0263</span>, <span class="number">3.0888</span>, <span class="number">3.0818</span>],</span><br><span class="line">        [<span class="number">3.1101</span>, <span class="number">2.7490</span>, <span class="number">3.1847</span>, <span class="number">3.0861</span>],</span><br><span class="line">        [<span class="number">2.8530</span>, <span class="number">2.8666</span>, <span class="number">2.9634</span>, <span class="number">3.1875</span>]])</span><br></pre></td></tr></table></figure></li></ul><h1>简易深度学习模型的实现(线性回归)</h1><h2 id="1-生成正态分布的数据">1. 生成正态分布的数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>): <span class="comment">#@save</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w))) <span class="comment"># 按数据规模随机生成原始数据</span></span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape) <span class="comment"># 加上正态分布噪声</span></span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>其中features中的每⼀⾏都包含⼀个⼆维数据样本，labels中的每⼀⾏都包含⼀维标签值（⼀个标量）</p><p>简记：<code>feature</code>为自变量（可能多维），<code>lables</code>为函数</p><h2 id="2-读取数据集">2. 读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_examples = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_examples))</span><br><span class="line">    <span class="comment"># 这些样本是随机读取的，没有特定的顺序</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        batch_indices = torch.tensor(</span><br><span class="line">            indices[i: <span class="built_in">min</span>(i + batch_size, num_examples)])</span><br><span class="line">        <span class="keyword">yield</span> features[batch_indices], labels[batch_indices]</span><br></pre></td></tr></table></figure><p>每次随机返回至多<code>batch_size</code>组数据</p><p>使用示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">    <span class="built_in">print</span>(X, <span class="string">&#x27;\n&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>但这种简易的随机读取数据的方式效率不佳</p><h2 id="3-参数的初始化及一队定义">3. 参数的初始化及一队定义</h2><h3 id="初始化超参数">初始化超参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, size=(<span class="number">2</span>,<span class="number">1</span>), requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.zeros(<span class="number">1</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="线性回归模型">线性回归模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">X, w, b</span>): <span class="comment">#@save</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;线性回归模型&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> torch.matmul(X, w) + b</span><br></pre></td></tr></table></figure><p>当我们⽤⼀个向量加⼀个标量时，标量会被加到向量的每个 分量上。</p><h3 id="损失函数">损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>): <span class="comment">#@save</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;均⽅损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="优化算法">优化算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>): <span class="comment">#@save</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;⼩批量随机梯度下降&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param -= lr * param.grad / batch_size</span><br><span class="line">        param.grad.zero_()</span><br></pre></td></tr></table></figure><h2 id="3-训练">3.训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        l = loss(net(X, w, b), y) <span class="comment"># X和y的⼩批量损失</span></span><br><span class="line">        <span class="comment"># 因为l形状是(batch_size,1)，⽽不是⼀个标量。l中的所有元素被加到⼀起，</span></span><br><span class="line">        <span class="comment"># 并以此计算关于[w,b]的梯度</span></span><br><span class="line">        l.<span class="built_in">sum</span>().backward()</span><br><span class="line">        sgd([w, b], lr, batch_size) <span class="comment"># 使⽤参数的梯度更新参数</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        train_l = loss(net(features, w, b), labels)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;<span class="built_in">float</span>(train_l.mean()):f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>线性模型的简单实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>) : <span class="comment">#@save</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w))) <span class="comment"># 按数据规模随机生成原始数据</span></span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape) <span class="comment"># 加上正态分布噪声</span></span><br><span class="line">    <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = d2l.synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># is_train参数表示是否每个迭代周期打乱数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_array</span>(<span class="params">data_arrays, batch_size, is_train=<span class="literal">True</span></span>) : <span class="comment">#@save</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;构造⼀个PyTorch数据迭代器&quot;&quot;&quot;</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">next(iter(data_iter))调用这个迭代器</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment"># Sequential实现神经网络多层的串联</span></span><br><span class="line"><span class="comment"># Linear全连接层</span></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># net[0]访问第一层</span></span><br><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 平方L2范数，即均方误差</span></span><br><span class="line">loss = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化算法：小批量梯度随机下降</span></span><br><span class="line"><span class="comment"># lr 为学习率</span></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">num_epochs = <span class="number">3</span> <span class="comment"># 迭代周期个数</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        l = loss(net(X) ,y)</span><br><span class="line">        trainer.zero_grad()</span><br><span class="line">        l.backward()</span><br><span class="line">        trainer.step()</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">w = net[<span class="number">0</span>].weight.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;w的估计误差：&#x27;</span>, true_w - w.reshape(true_w.shape))</span><br><span class="line">b = net[<span class="number">0</span>].bias.data</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b的估计误差：&#x27;</span>, true_b - b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
